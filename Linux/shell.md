[TOC]

## Shell

### 脚本的执行方式

- bash xx.sh
- sh xx.sh
- ./sh
- bash -x xxx.sh 查看脚本的执行过程

### 交互式定义变量(read)

read [options] variables

- -p 定义提示用户的信息
- -n 定于字符数
- -s 不显示用户输入的内容
- -t 定义超时时间

```bash
# 从文件中读取一行数据复制给name
read name < file
```

定义有类型的变量(declare)

declare [options] variables=value

unset variables: 取消赋值操作

- -i 将变量看成整数
- -r 定义只读变量
- -a 定义为普通数组
- -A 定义关联数组
- -x 将变量通过环境导出

### 变量的分类

#### 本地变量

当前用户自定义的变量。当前进程中进程有效(一个bash终端就是一个进程), 其他进程以及当前进程的子进程无效

#### 环境变量

当前进程有效, 并且能够被子进程调用

- env 查看当前用户的环境变量
- set 查询当前用户的所有变量(临时变量和环境变量)

```bash
# 导出环境变量
export A=123 -> declare -x A=123
# 查看环境变量
env | grep A
```

#### 全局变量

```bash
# 当前用户的bash信息 用户登陆时读取
$HOME/.bashrc
```

```bash
# 当前用户的环境变量, 用户登陆时读取
$HOME/.bash_profile
```

```bash
# 当前用户退出当前shell时读取
$HOME/.bash_logout
```

```bash
# 全局的bash信息, 所有的用户都生效
/etc/bashrc
```

```bash
# 全局环境变量信息
/etc/profile
```

用户登系统读取相关文件的顺序

- `/etc/profile`
- `$HOME/.bash_profile`
- `$HOME/.bashrc`
- `/etc/bashrc`
- `$HOME/.bash_logout`

#### 系统变量(内置bash变量)

| 内置变量     | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| $?           | 上一条命令执行返回后的状态; 状态值为0表示正常执行, 非0表示执行异常或者错误 |
| $0           | 当前执行的程序或脚本名                                       |
| $#           | 脚本后面接的参数个数                                         |
| $*           | 脚本后面所有参数, 参数当成一个整体输出, 每一个变量变量之间以空格隔开 |
| $@           | 脚本后面所有的参数, 参数是独立的, 也是全部输出               |
| $1-$9        | 脚本后面的参数位置 $1表示第一个位置参数                      |
| ${10} - ${n} | 扩展位置参数 {2个数字以上括起来}                             |
| $$           | 当前所在进程的进程号                                         |
| $!           | 后台运行的最后一个进程号                                     |
| !$           | 调用最后一条命令历史中的参数                                 |

```bash
echo "\$0 = $0"
echo "\$# = $#"
echo "\$* = $*"
echo "\$@ = $@"
echo "\$1 = $1"
echo "\$2 = $2"
echo "\$3 = $3"
echo "\$10 = ${10}"
```

```
./test.sh a b c d e f g h i j
```

```bash
$0 = ./test.sh
$# = 10
$* = a b c d e f g h i j
$@ = a b c d e f g h i j
$1 = a
$2 = b
$3 = c
$10 = j
```

### 四则运算

- $(()) echo $((1+1))
- $[]    echo $[3+2]
- expr expr 10 \* 5 (需要将*转义, 且操作数和\*号之间一定要有空格)
- let     n=1; let n+=1(不可以有空格)
- 2**2 次方运算 (expr不支持)
- bc

### 条件判断

- test 条件表达式
- [ 条件表达式 ]
- [[ 条件表达式 ]] : 支持正则 (注:两边中括号和表达式之间都有空格

#### 判断文件类型

| 判断参数 |                  含义                  |
| :------- | :------------------------------------: |
| -e       |     判断文件是否存在(任何类型文件)     |
| -f       |   判段文件是否存在并且是一个普通文件   |
| -d       |     判断文件是否存在并且是一个目录     |
| -L       |  判断文件是否存在并且是一个软链接文件  |
| -b       |  判断文件是否存在并且是一个块设备文件  |
| -S       |  判断文件是否存在并且是一个套接字文件  |
| -c       |   判断文件是否存在并且是一个字符文件   |
| -p       | 判断文件是否存在并且是一个命名管道文件 |
| -s       |   判断文件是否存在并且是一个非空文件   |

#### 判断文件权限

| 判断参数 |            含义            |
| :------- | :------------------------: |
| -r       |    当前用户对其是否可读    |
| -w       |    当前用户对其是否可写    |
| -x       |    当前用户对其是否可读    |
| -u       | 是否有suid 高级权限冒险位  |
| -g       | 受否有sgid 高级权限强制位  |
| -k       | 当是否育t位 高级权限强制位 |

#### 判断整数

| 判断参数 | 含义     |
| :------- | -------- |
| -eq      | 相等     |
| -ne      | 不等     |
| -gt      | 大于     |
| -lt      | 小于     |
| -ge      | 大于等于 |
| -le      | 小于等于 |

#### 判断字符串

| 判断参数 | 含义                              |
| :------- | --------------------------------- |
| -z       | 判断是否为空字符串(长度为0即为空) |
| -n       | 判断是否为非空字符串              |
| =        | 判断字符串是否相等                |
| !=       | 判断字符串是否不相等              |

#### 多重条件判断符

| 判断符号       | 含义   | 举例                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| -a(all) 和 &&  | 逻辑与 | [ $(id -u) -eq 0 ] && echo "admin"          [ 0 -lt 1 -a 1 -lt 0 ]; echo $? |
| -o(or) 和 \|\| | 逻辑或 | [ 0 -lt 1 -o 1 -lt 0 ]; echo $?                              |

注: && 前面的表达式为真时, 才会执行后面的代码

|| 前面的表达式为假, 才会执行后面的代码

; 用于分割命令或者表达式

#### 条件判断(C风格)

` (( 1 == 3)); echo $?`

`[ "hello" = "world" ]; echo $? `  当使用[]时用加引号

`a="hello";b="world";[ "$a" = "$b" ]; echo $?`

`[[ hello = hello ]]; echo $?` 使用[[]]时不用加引号

###  输出文件file.txt的第十行内容

file.txt

```bash
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
```

```bash
awk 'NR == 10' file.txt 
```

```bash
sed -n 10p file.txt
```

```bash
tail -n+10 file.txt | head -1
```

```shell
# /bin/bash
count=`cat file.txt | wc -l`
out=`cat file.txt | head -10 | tail -1`
if [ $count -lt 10 ]
then
    echo ""
else echo $out
fi
```

```shell
# /bin/bash
c=10
cat file.txt|
while read line
do
    if [ $c == 1 ]
    then
        echo $line
        exit 0
    fi
    c=$(($c-1))
done
```

