# 目录

[TOC]

## redis persistence

Redis 的持久化主要有两大机制, 即 AOF (Append Only File) 日志和 RDB 快照

### RDB(Redis Database)

在指定的时间间隔内将内存中的数据集快照写入磁盘,即快照; 数据恢复时直接将快照文件读入内存中

#### SNAPSHOTTING快照

```shell
dbfilename dump.rdb   # 默认持久化到dump.rdb文件中 
save 900 1            # 15分钟内保存一次即修改一次
save 300 10           # 5分钟内保存十次即修改十次
save 60 10000         # 1分钟内保存一万次即修改一万次
stop-writes-on-bgsave-error yes  # 保存出错停止写入
rdbcompression yes    # 数据压缩
rdbchecksum yes       # 数据校验
dir ./                
config get dir        # 获取redis启动路径
save                  # 手动备份
```

RDB适合大规模的数据恢复, 而且对数据的完整性和一致性要求不高

### AOF(Append Only File)

数据库的写前日志(Write Ahead Log, WAL), 也就是说, 在实际写数据前, 先把修改的数据记到日志文件中(redo log和binlog是在commit之前写的日志), 
以便故障时进行恢复; 不过, AOF 日志正好相反, 它是写后日志, "写后"的意思是 Redis 是先执行命令, 把数据写入内存, 然后才记录日志

传统数据库的日志, 例如 redo log(重做日志), 记录的是修改后的数据, 而 AOF 里记录的是 Redis 收到的每一条命令, 这些命令是以文本形式保存

AOF 为什么要先执行命令再记日志?

为了避免额外的检查开销, Redis 在向 AOF 里面记录日志的时候, 并不会先去对这些命令进行语法检查; 所以, 如果先记日志再执行命令的话, 日志中就有可能记录了错误的命令, Redis 在使用日志恢复数据时, 就可能会出错

Redis 使用写后日志这一方式的一大好处是, 可以避免出现记录错误命令的情况; 除此之外, AOF 还有一个好处: 它是在命令执行后才记录日志, 所以不会阻塞当前的写操作

AOF 两个潜在的风险:

如果刚执行完一个命令, 还没有来得及记日志就宕机了, 那么这个命令和相应的数据就有丢失的风险

AOF 虽然避免了对当前命令的阻塞, 但可能会给下一个操作带来阻塞风险; 这是因为, AOF 日志也是在主线程中执行的, 如果在把日志文件写入磁盘时, 磁盘写压力大, 就会导致写盘很慢, 进而导致后续的操作也无法执行了

以日志的形式记录每个写操作, 将Redis所有的写指令记录下来(不记录读操作), 只许追加文件不许修改文件, 相当于MySQL的脚本文件, 当Redis启动时就会加载appendonly.aof文件将写指令重新执行一遍来恢复数据

AOF 三种写回策略

- always, 同步写回: 每个写命令执行完, 立马同步地将日志写回磁盘

- everysec, 每秒写回: 每个写命令执行完, 只是先把日志写到 AOF 文件的内存缓冲区, 每隔一秒把缓冲区中的内容写入磁盘
- no, 操作系统控制的写回: 每个写命令执行完, 只是先把日志写到 AOF 文件的内存缓冲区, 由操作系统决定何时将缓冲区内容写回磁盘

![img](https://cdn.qingweico.cn/blog/72f547f18dbac788c7d11yy167d7ebf8.jpg)

AOF 重写机制

产生原因:

AOF 是以文件的形式在记录接收到的所有写命令, 随着接收的写命令越来越多, AOF 文件会越来越大, AOF 文件过大会带来性能问题

- 文件系统本身对文件大小有限制, 无法保存过大的文件
- 如果文件太大, 之后再往里面追加命令记录的话, 效率也会变低
- 如果日志文件太大, 整个恢复过程就会非常缓慢

AOF 重写机制就是在重写时, Redis 根据数据库的现状创建一个新的 AOF 文件, 也就是说, 读取数据库中的所有键值对, 然后对每一个键值对用一条命令记录它的写入

旧日志文件中的多条命令, 在重写后的新日志中变成了一条命令(AOF 文件是以追加的方式, 逐一记录接收到的写命令的; 当一个键值对被多条写命令反复修改时, AOF 文件会记录相应的多条命令; 但是, 在重写的时候, 是根据这个键值对当前的最新状态, 为它生成对应的写入命令)

注意, AOF的重写不是根据原有的AOF去做, 而是根据当前内存数据库的数据, 去生成一条条命令进行保存

和 AOF 日志由主线程写回不同, 重写过程是由后台子进程 bgrewriteaof 来完成的, 这也是为了避免阻塞主线程, 导致数据库性能下降

#### APPEND ONLY MODE

```shell
appendonly no  # 默认关闭 yes即代表打开aof的持久化
appendfilename "appendonly.aof"
```

```bash
redis-check-aof --fix appendonly.aof # 修复appendonly.aof文件
```

dump.rdb文件和appendonly.aof文件可以同时存在,当二者同时存在时优先加载appendonly.aof文件

```shell
# appendfsync always # 同步持久化 每当有数据发生变化时就会记录到磁盘 数据完整性好但是性能差
appendfsync everysec # 出厂默认 异步操作 每秒记录数据 1s内宕机 数据丢失
# appendfsync no
```



