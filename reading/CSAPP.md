## 第一章

```shell
#预处理器阶段
g++ -o HelloWorld.i -E HelloWorld.cpp
```

```shell
#编译期阶段
g++ -o HelloWorld.s -S HelloWorld.i
```

```shell
#汇编器阶段
g++ -o HelloWorld.o -c HelloWorld.s
```

```shell
#连接器阶段
gcc -o Helloworld.exe HelloWorld.o
```

预处理器、编译期、汇编器和链接器一起构成了编译系统

计算机系统是由硬件和系统软件组成的,它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位,它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式,开始时是ASCII文本,然后被编译器和链接器翻译成二进制可执行文件

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间赋值数据,所以将系统中存储设备划分成层次结构——CPU寄存器在顶部,接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层级模型中,位于更高层的存储设备比低层的存储设备要更快,单位比特造价也更高。层级结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识,程序员可以优化C程序的性能

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象: 1) 文件是对I/O设备的抽象; 2) 虚拟内存是对主存和磁盘的抽象; 3) 进程是处理器、主存和I/O设备的抽象

最后,网络提供了计算机系统之间通信的手段。从特殊系统的角度来看,网络就是一种I/O设备

## 第二章

对于一个[x<sub>w-1</sub>, w<sub>w-2</sub>, ..., x<sub>0</sub>]的操作数

逻辑右移(x >> k): 逻辑右移在左端补k个0,得到结果[0, ..., 0, x<sub>w-1</sub>, w<sub>w-2</sub>, ..., x<sub>k</sub>]

算术右移(x >> k):算术右移是在左端补k个最高有效位的值,得到的结果是[x<sub>w-1</sub>, ..., w<sub>w-1</sub>,  w<sub>w-1</sub>, w<sub>w-2</sub>, ..., x<sub>k</sub>]。 这种做法看上去可能有点奇特,但是我们发现它对有符号整数数据的运算非常有用

| 参数x            | [0110 0011]  [1001 0101] |
| ---------------- | ------------------------ |
| x << 4           | [0011 0000] [0101 0000]  |
| x >> 4(逻辑右移) | [0000 0110] [0000 1001]  |
| x >> 4(算术右移) | [0000 0110] [1111 1001]  |

C语言标准并没有名确定义对于有符号数应该使用那种类型的右移——算术右移或者逻辑右移都可以

几乎所有的编译器/机器组合都对有符号数使用算术右移,对于无符号数,右移必须是逻辑的

与C相比,Java对于如何进行右移有着明确的定义。表达式x >> k 会将x算术右移k个位置,而x >>> k会对x做逻辑右移

对于一个由w位组成的数据类型,如果要移动k >= w位,移位指令只考虑位移量的低log<sub>2</sub>w位,因此实际上的位移量就是通过计算k  mod w得到的,不过这种行为对于C程序来说是没有保证的,所以应该保持位移量小于待位移值的位数,另一方面,Java特别要求位移量应该按照求模的方法来计算

加法和减法的优先级比移位运算要高

Ｃ和Ｃ＋＋都支持有符号(默认)和无符号数．Java只支持有符号数