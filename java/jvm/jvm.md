目录

[TOC]

# JVM

*![](https://img.imgdb.cn/item/601773e53ffa7d37b3a530f6.png)*

## 1 类加载器

### 1.1 类的加载过程

- 加载

```properties
1:通过一个类的全限定名称获取此类的二进制字节流
2:将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3:在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
```

- 链接
  - 验证
  - 准备
  - 解析

- 初始化

```properties
执行类构造器方法<clinit>()
此方法不需要定义, 是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
构造器方法中指令按语句在源文件中出现的顺序执行
<clinit>不同于类的构造器（关联: 构造器是虚拟机视角下的<init>()）
若该类具有父类, JVM会保证子类的<clinit>()执行前, 父类的<clinit>()已经执行完毕
虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁
```

### 1.2 类加载器的分类

- 引导类加载器(BootStrap Class Loader )：包括系统类加载器(System Class Loader) 和扩展类加载器(Extension Class Loader)
- 自定义类加载器(User-Defined Class Loader)

**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器(不包括引导类加载器)**

引导类加载器：使用C/C++代码实现, 嵌套在JVM内部

系统类加载器(AppClassLoader)：程序中通过默认的类加载器

### 1.3 双亲委派机制

工作原理:

```properties
1>: 如果一个类加载器收到了类加载子请求, 它并不会自己先去加载, 而是把这个请求委托给父类的加载器去执行
2>: 如果父类加载器还存在其父类加载器, 则近一步向上委托, 依次递归, 请求最终到达顶层的启动类加载器
3>: 如果父类加载器可以完成类加载任务, 就成功返回, 倘若父类加载器无法完成此加载任务, 子加载器才会尝试自己去加载, 这就是双亲委派机制
```

在JVM中表示两个class对象是否为同一个类存在的两个必要条件

- 类的完整类名必须一致, 包括包名
- 加载这个类的ClassLoader(指ClassLoader实例对象)必须相同

对类加载器的引用：

```properties
JVM必须知道一个类型是由引导类加载器加载的还是由用户类加载器加载的.
如果一个类型是由用户类加载器加载的, 那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法去中.
当解析一个类型到另外一个类型的引用的时候, JVM需要保证这两个类型的类加载器是相同的.
```

## 2 运行时数据区

方法区和堆有GC, 虚拟机栈和本地方法区以及程序计数器则没有GC

方法区和堆为所有线程所共享, 而虚拟机栈和本地方法区以及程序计数器则每个线程各有一份

### 2.1 PC寄存器

程序计数器也叫PC寄存器

JVM中PC寄存器是对物理寄存器的一种抽象模拟

程序计数器是唯一一个在JVM没有规定任何OutOfMemoryError情况的的区域

PC寄存器的作用：

```properties
PC寄存器用来存储指向下一条指令的地址(偏移地址), 即将要执行的指令代码, 由执行引擎读取下一条指令.
```

PC寄存器被设定为线程私有的原因:

```properties
在多线程环境中, 一个特定的时间段只会执行其中某一个线程的方法, CPU会不停地做任务切换, 这样必然会导致线程中断和恢复, 为了能够准确地记录各个线程正在执行地当前字节码指令地址, 最好的办法自然是为每一个线程都分配一个PC寄存器, 这样一来各个线程之间便可以进行独立计算, 从而不会出现相互干扰的情况.
```

CPU时间片即CPU分配给各个程序的时间, 每个线程被分配一个时间段,  称作它的时间片

### 2.2 虚拟机栈

由于跨平台的设计, Java的指令都是根据栈来设计的, 因为不同平台CPU架构不同, 所以不能设计为基于寄存器的

虚拟机栈的 **优点**是: 指令集小, 编译器容易实现 **缺点**是性能下降, 实现同样的功能需要更多的指令

作用：主管Java程序的运行, 它保存方法的局部变量、部分结果, 并参与方法的调用和返回

生命周期: 生命周期和线程一致

每个线程在创建时都会创建一个虚拟机栈, 其内部保存一个个的栈帧(Stack Frame), 对应着一次次Java方法调用

栈的特点：

- 栈是一种快速有效的分配存储方式, 访问速度仅次于PC寄存器
- JVM直接对虚拟机栈的操作只有两个
  - 每个方法执行, 伴随着进栈(入栈、压栈)
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题(但是存在OOM和SOF问题)

```properties
-Xss1k/1m/1g 设置虚拟机栈内存的大小
-Xss1024 不加单位默认为字节
```

栈运行原理:

- 不同线程中所包含的栈帧是不允许存在相互引用的, 即不可能在一个栈帧之中引用另外一个线程的帧.
- 如果当前方法调用了其他方法, 方法返回之际, 当前栈帧回传会此方法的执行结果给前一个栈帧, 接着, 虚拟机会丢弃当前栈帧, 使得前一个栈帧重新成为当前栈帧.
- Java方法有两种返回函数的方式, 一种是正常的函数返回, 使用return指令; 另一种是抛出异常. 不管使用哪种方式, 都会导致栈帧被弹出.

#### 2.2.1 栈帧的内部结构

每个栈帧中储存着：

- 局部变量表(Local Variables)
- 操作数栈(Operand Stack)(或表达式栈)
- 动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)
- 方法返回地址(Return Address）(或方法正常退出或者异常退出的定义)
- 一些附加信息

#### 2.2.2 局部变量表

- 局部变量表也称之为局部变量数组或本地变量表
- 定义为一个数字数组，主要用来储存方法参数和定义在方法体内的的局部变量，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
- 局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的maximun local variables数据项中。在方法运行期间是不会改变局部变量表的大小的
- 方法嵌套的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少
- 局部变量表只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数列表的传递过程。当方法调用结束后，随着方法栈的销毁，局部变量表也会销毁
- 局部变量表，最基本的储存单是Slot(变量槽)

##### 2.2.2.1关于Slot的理解

```properties
1> JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引1即可成功访问到局部变量表中指定的局部变量值
2> 当一个实例方法调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
3> 如果需要访问局部变量表中的一个64bit的局部变量值时，只需要使用前一个索引即可（注:32位以内的类型只占一个和slot（包括returnAddress）, 64位的类型（long和double占用两个slot））
4> 如果当前帧是由构造方法或者实列方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数顺序表顺序继续排列
```

栈帧中局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量可能会复用过期局部变量的槽位，从而达到节省资源的目的

##### 2.2.2.2 总结

- 在栈帧中，与性能调优最为密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递
- 局部变量中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收

#### 2.2.3 操作数栈

- 操作数栈，主要用于保存计算的中间结果，同时作为计算过程中变量临时的储存空间
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于储存数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值
- 栈中的任何一个元素都可以是任意的Java数据类型
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
- 另外，我们说Java虚拟机的解析引擎是基于栈的执行引擎，其中的栈指的就是操作数栈

#### 2.2.4 动态链接

- 每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接
- 在Java源文件被编译到字节码文件中，所有的变量和方法引用都作为符号引用(symbolic Reference) 保存在class文件的常量池里。比如描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

##### 2.2.4.1 为什么需要常量池:

```properties
常量池的作用就是提供一些符号和常量，便于指令的识别以及资源的共享和复用
```

##### 2.2.4.2 方法的调用:

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

- 静态链接(静态绑定): 当一个字节码文件被装进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
- 动态链接(动态绑定): 如果被调用的·1方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具有动态性，因此被称为动态链接

##### 2.2.4.3 虚方法和非虚方法

- 普通调用指令
  - invokestatic: 调用静态方法，解阶段确定唯一方法版本
  - invokespecial: 调用<ini t>方法、私有方法以及父类方法，解析阶段确定唯一方法版本
  - invokevirtual: 调用所有的虚方法
  - invokeinterface: 调用接口方法
- 动态调用指令
  - invokedunamic: 动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法的版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法

##### 2.2.4.4 关于invokedynamic指令

invokedynamic指令于Java7添加，是为了能够让Java支持动态类型语言而做的一种改进（使用Lamabda表达式可以直接生成）

Java7中增加的动态类型语言支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改

动态类型语言和静态类型语言

动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言

静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息

Java是静态类型的语言    

#### 2.2.5 方法返回地址

存放调用该方法的pc寄存器的值

- 无论方法正常退出还是异常退出都会回到该方法被调用的位置。方法正藏退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息
- 本质上，方法的退出就是当前栈帧出栈的过程。此时。需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去
- 正常完成出口和异常完成出口的区别在于: 通过异常完成出口退出的不会给它的上层调用者产生任何的返回值
- 执行引擎遇到任意一个方法返回的字节码指令(return),会有返回值传递给上层的方法调用者，简称正常完成出口
  - 一个正常方法调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定
  - 在字节码指令中，返回指令包含ireturn(当前返回值是boolean、byte、char、short、int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型)。另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用
- 在方法执行过程中遇到了异常，并且这个异常没有在方法内处理，也就是没有在本地的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口(方法执行过程中抛出异常时的异常处理，储存在一个处理表中)

#### 2.2.6 一附加信息

栈帧中还允许携带与ava虚拟机实现相关的一些附加信息，比如对程序调试提供支持的信息

### 2.3 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
- 本地方法栈，也是线程私有的
- 允许被实现成固定或者是可扩展的内存大小
  - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
  - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutofMemoryError异常
- 本地方法是使用C/C++语言实现的
- 加载本地方法的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存
- 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈
- 在HotSpot中，直接将本地方法栈和虚拟机栈合二为一

### 2.4 堆

- 一个JVNM实例只存在一个堆内存，堆也是Java内存管理的核心区域
- Java堆内存的JVM启动的时候即被创建，其空间大小也就确定了。堆区是JVM管理的最大一块内存空间(堆内存的大小是可以调节的)
- 《JVM虚拟机规范》规定，堆可以处于物理上不连续的内存空间，但是在逻辑上它应该被视为连续的
- 所有的的线程共享Java堆，在这里还可以划分为线程私有的缓冲区(Thread Local Allocation Buffer TLAB)
- 堆，是GC(Garbage Collecion 垃圾回收器) 执行垃圾回收的重点区域
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会移出(GC的启动也需要消耗系统资源，所以GC并不会频繁的启动)

```properties
#打印虚拟机参数(加号表示启用 减号表示不启用)
java -XX:+PrintFlagsFinal | wc -l 
```

```properties
-Xms20m -Xmx20m(默认单位字节) -XX:+PrintGCDetails
```

现代垃圾收集器都基于分代收集理论设计，堆内存逻辑上细分为新生代、老年代以及元空间(Java8之前叫做永久代)

#### 2.4.1  堆空间大小的设置

- -Xms 用于设置堆区的起始内存(年轻代 +老年代)，等价于-XX:InitialHeapSize

- -Xmx 则用于设置堆区的最大内存(年轻代 +老年代)，等价于-XX:MaxHeapSize

- 一旦堆区中的内存大小超过了-Xmx所指定的最大内存时，将会抛出OutofMemoryError异常

- 通常会将-xms和-Xmx两个参数配置相同的值，其目的在于为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能

- 默认堆空间的大小

  - 初始内存大小：物理电脑内存 / 64
  - 最打内存大小：物理内存大小 / 4

- 查看设置堆空间的参数的详细信息

  ```properties
  #方式一
  1> jps
  2> jstat -gc 进程id
  #方式二
  -XX:PrintGCDetails
  ```

#### 2.4.2  年轻代和老年代

- 储存在JVM中Java对象可以被划分为两类

  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端情况下还能够与JVM的生命周期保持一致

- Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(OldGen)

- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫from区、to区)

- 配置年轻代和老年代在堆结构的占比

  ```properties
  -XX:NewRatio=2 表示新生代占1.老年代占2，新生代占整个堆的1/3
  ```

- 查看默认年轻代和老年代在堆结构的占比

  ```properties
  #显示当前所有java进程pid
  jps
  #查看默认年轻代和老年代在堆结构的占比为2(新生代占1.老年代占2)
  jinfo -flag NewRatio 进程pid
  >>> -XX:NewRatio=2
  #查看Eden空间和另外两个Survivor空间缺省所占的比例(默认Eden空间占8份)
  jinfo -flag SurvivorRatio 进程pid
  >>> -XX:SurvivorRatio=8
  ```

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1

- 可以使用选项-XX:SurvivorRatio调整这个空间比例

- 几乎所有的Java对象都是在Eden区被new出来的

- 绝大部分的Java对象的销毁都是在年轻代进行的

- 可以使用选项-Xmn设置新生代最大内存大小

- 关于垃圾回收: 频繁的新生区收集，很少在养老区收集，几乎不在元空间收集

- YGC:年轻代中的垃圾回收器

- FGC:老年代中的垃圾回收器

