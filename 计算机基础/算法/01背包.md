## 01背包

### 问题描述

**有n个物品,它们有各自的体积和价值,现有给定容量的背包,如何让背包里装入的物品具有最大的价值总和？**

核心思想： 

- 若当前物品体积大于当前背包容量 ,不装,此时背包中的最大价值仍然是上一次的值
- 若当前物品体积不大于当前背包容量,可以尝试装,但是又怕装了当前物品后总的体积大于当前背包的容量,比如当前背包的体积为5,当前物品的体积为3,所以可以尝试装入该物品,但是在这之前该背包已经装入了体积为3的物品,再装入该物品,总体积大于了所给背包的容量,显然不合题意。所以可以尝试先将前一个物品从背包中剔除掉,将当前物品加入,这样肯定不会超出当前背包的容量,因为条件就是当前物品的体积不大于背包的容量,所以可以比较不装当前物品时背包的总价值和装了当前物品后但是剔除了前一个物品后该背包的总价值,选取最大价值的方案即可

```java
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1, 4, 3};
        int[] v = {1500, 3000, 2000};
        int m = 4; //背包的容量
        int n = v.length; //物品的个数
        int[][] dp = new int[n+1][m+1];
        for(int i = 1; i < dp.length; i++) {
            for(int j = 1; j < dp[0].length; j++) {
                if(w[i-1] > j) { //i是从1开始的,因此原来公式中的 w[i] 修改成 w[i-1]
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], v[i-1]+dp[i-1][j-w[i-1]]);
                }
            }
        }
        System.out.println(dp[dp.length-1][dp[0].length-1]);
    }
}
```

公式：

| `w[i]` 表示当前物品的体积  `j` 表示当前背包的容量 | i表示可有物品的选择个数                                 |
| ------------------------------------------------- | ------------------------------------------------------- |
| w[i] > j                                          | `dp[i][j] =  dp[i-1][j]`                                |
| w[i] <= j                                         | `dp[i][j] = Math.max(dp[i-1][j], v[i]+dp[i-1][j-w[i]])` |

