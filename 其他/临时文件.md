高性能：响应（低延迟） 吞吐（高吞吐量 高并发）

amdahl定律

TPS QPS

JOL

加锁 （synchronized 悲观锁 互斥锁）并发执行 --------> 序列化执行

CSA(Compare And Set / compare And Swap) 

ABA问题： 版本号(AtomticStampedReference)或者 使用 Boolean(AtomticMarkableReference)标记

CAS原子性问题： cmpxchg ---->cpu的指令 汇编指令 

cas操作 cpu本身有指令支持   cmpxchg  不支持原子性

LOCK_IF_MP cmpxchg === lock cmpxchg 

单个cpu不用加lock

lock优先锁定cache line 其次锁定北桥信号

能用synchronized解决问题的 优先使用synchronized

CFS(操作系统线程调度算法)

JDK1.5之后synchronized内部有锁升级的过程 ,偏向锁 --->自旋锁(轻量级cas锁)---->重量级锁（悲观排队锁）

内存屏障 (memory barrier) lfency sfency mfency

是不是cas就一定比悲观锁效率高?
不一定，取决于单个线程的执行时间以及等待线程的数量

nc www.baidu.com

GET / HTTP/1.0

netstat -natp

tcpdump  -nn -i eth0 port 80

curl www.baidu.com



