# 目录

[TOC]

## JDK和JRE的区别

JDK是整个Java的核心, 包括了Java运行环境JRE, 一堆Java工具和Java基础的类库; 通过JDK开发人员将源码文件编译成成字节码文件; JRE则是Java运行的环境, 不含开发环境, 即没有编译器和调试器, 将class文件加载到内存中准备运行

----

## final关键字  抽象类可以被final修饰吗

- 用来修饰数据, 包括成员变量和局部变量, 该变量只能被赋值一次且它的值不能被修改, 而对于成员变量必须在声明时赋值, 最迟要在构造方法中赋值 
- 修饰方法, 表示该方法无法被重写 
- 修饰类, 表示该类无法被继承
- 抽象类是用于被继承的, final修饰代表不可修改, 不可继承, 所以不能使用final修饰类

------

## JAVA容器

- ArrayList底层数组实现, 封装了常见的增删改查的操作, 并且支持动态扩展, 适合查找多的场合 

- LInkedList是基于链表实现的列表, 适合增删较多的场合 

- TreeSet是基于二叉排序树(**红黑树**)实现的, TreeSet里面最典型的就是用到了两种排序方式

  - 基于元素对象自身的实现的Comparable接口的自然排序 

  - 基于更为灵活不与单个元素绑定的Comparator接口的客户化排序(自己在构造的时候传入一个比较器即可)

- HashMap是用来储存键值对的映射关系, 底层使用数组+链表+红黑树实现的 

- HashSet是基于HashMap实现的, 只不过将值固定为一个固定的值(null) 

- LinkedHashMap支持按照插入顺序排序 

- PriorityQueue优先级队列 一个基于优先级堆(默认最小堆)的无界优先级队列  

##  线程安全体现在三个方面

- 原子性: 提供互斥访问, 同一时刻只能有一个线程对数据进行修改(atomic synchronized) 
- 可见性: 一个线程对内存的修改可以及时的被其他线程看到(volatile synchronized) 
- 有序性: 一个线程观察其他线程中的指令执行顺序, 由于指令重排序, 该观察结果一般杂乱无序(happens-before) 

## Java如何保证原子性

锁和同步

常用的保证Java操作原子性的工具是锁(lock)和同步方法(或者同步代码快), 使用锁, 可以保证同一时间只有一个现线程能拿到锁, 也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码

- 使用非静态同步方法时, 锁住的是当前实例 
- 使用静态同步方法时, 锁住的是该类的Class对象 
- 使用代码块时, 锁住的是synchronized关键字后面括号的内容 

无论是使用锁还是使用synchronized关键字, 本质都是一样的, 通过锁来实现资源的排它性, 从而实现目标代码段同一时间只能被一个线程执行, 进而保证目标代码段的原子性, 这是一种以牺牲性能为代价的方法

## Java如何保证可见性

Java提供volatile关键字来保证可见性

 由于JVM是基于共享内存实现线程通讯的, 所以会存在缓存一致性的问题; 当使用volatile修饰某个变量时, 它会保证对该变量的修改会立即被更新到内存中, 并且将其他缓存中对该变量的缓存设置为无效, 因此其他线程需要读取该值时必须从主内存中读取, 从而得到最新的值

## Java如何保证顺序性

编译器和处理器对指令进行重新排序时, 会保证重新排序后的执行结果和代码顺序执行的结果一致, 所以重新排序过程并不会影响到单线程程序的执行, 却可能影响多线程程序并发执行的正确性; Java中可通过volatile在一定程序上保证顺序性, 另外还可以通过synchronized和锁来保证顺序性; synchronized和锁保证顺序的原理和原子性一样, 都是*保证同一时间只会有一个线程执行目标代码段来实现的*; 除了从应用层面保证目标代码段执行的顺序性之外, JVM还通过被称为 ***happens-before***原则隐式的保证顺序; 两个的操作顺序只要可以通过happens-before推导出来, 则JVM会保证其顺序性, 反之JVM对其顺序不做任何保证, 可以对其进行必要的重新排序一获取高效率

## 有没有其他方法保证线程安全？

 有, 尽可能避免引用非线程安全的条件——共享变量 如果能从设计上避免共享变量的使用, 即可避免非线程安全的发生, 也就无需通过锁或者synchronized以及volatile解决原子性, 可见性和顺序性的问题还有***不可变对象***, 可以使用final修饰的对象保证线程安全, 由于final修饰的引用型变量(***除了String外***)不可变是指引用不可变, 但其指向的对象内容是可变的, 所以此类必须安全发布, 即不能对外提供可以修改final对象的接口

---

