[TOC]

### 说一下HashMap和HashTable的区别吧

- HashMap的基类是AbstractMap, 基接口是Map; 而HashTable的基类是Dictionary, 基接口是Map
- HashMap的初始容量是16, 而HashTable的初始容量为11, 负载因子都是0.75; 但是扩容机制不同, HashMap是旧数组长度*2, 而HashTable是旧数组长度 * 2 + 1
- HashMap是线程不安全的, 而HashTable是线程安全的, 因为所有的方法都使用了synchronized
- HashMap使用迭代器迭代, Iterator基于fail-fast机制, 而HashTable可以使用迭代器和枚举
- HashMap的K和V都可以为null, 而HashTable中都不能为null
- HashMap遍历顺序为对数组从左往右遍历, 而HashTable则相反
- 计算理念不同: HashMap 为了性能, 尽量使用位运算; HashTable为了减少冲突, 使得元素位置更加均匀
- HashMap中取消了contains方法和elements方法, 使用containsKey和containsValue, 但是HashTable中四个方法都有
- 对象的定位方法不同
  - HashMap, 使用K的hashCode进行高低16位&运算作为hash值, 和数组的长度减一进行&运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - HashTable使用K的hashCode直接作为hash值和数组长度进行求余运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - 扩容的时候是2的n次方进行扩容, hash值在和2的n次方进行求余运算和&运算的结果一样, 但是&运算要快得多
  - 因为扩容倍数的特殊性, 导致扩容后不需要重新计算键值对在新数组的位置, 只需要判断K的hash值多出来的那一位是0还是1, 如果是0, 新表中键值对的位置和旧表一样, 如果是1 新表中键值对的位置等于旧表的位置 +  旧表的长度
- 关于快速失败 fail-fast: 说的是在juc下的非线程安全集合, (除了Stack、Vector、Enum、HashTable、Properties) 在迭代的过程中一旦别的线程对集合本身进行了结构性的修改(长度变化了), 那么迭代立刻结束, 迭代器将抛出ConcurrentModificationException, 而线程安全的集合和juc包下的集合都是safe-fail

### 什么是死锁 死锁产生的条件 如何避免死锁

### 解释一下银行家算法

### 解释http协议 post和get的区别

### TCP和UDP的区别

### IP协议在哪一层 IP协议的作用

### cookie和session session存储在服务端哪里

### 什么是索引 索引的优缺点 一般对哪些字段加索引

### 什么是吞吐量

### 五层网络协议 七层网络协议

### 丢包发生在哪一层 为什么

### 如果电脑联网失败 是哪一层有问题 为什么

### 怎么发生丢包问题 ping命令 这个命令用到了哪些协议 ICMP协议 这个协议具体是怎么使用的

### 开机时操作系统的整个运转过程是怎样的

### 滑动窗口 求数组中连续k个数的最大平均值 

### 二叉树的序列化和反序列化

### 加油站问题

### 双亲委派模型的优势

### NoClassDefFoundError和ClassNotFoundException的区别

### ConcurrentHashMap原理  7和8的区别

jdk1.7

数据结构: ReentrantLock + Segment + HashEntry 一个Segment中包含一个HashEntry数组 每个HashEntry数组中又是一个链表结构

元素查询: 二次hash 第一次hash定位到Segment 第二次hash定位到元素所在的链表的头部

锁: Segment继承至ReentrantLock 锁定操作的Segment 其他的Segment不受影响 并发粒度为segment个数 可以通过构造函数指定 数组扩容不会影响其他的segment

get方法无需加锁 volatile保证

jdk1.8

数据结构: Synchronized + CAS + Node + 红黑树 锁粒度更细 效率更高 

扩容时 阻塞所有的读写操作 并发扩容

写操作无锁 Node的val和next使用volatile修饰 读写线程对该变量可见

数组用volatile修饰 保证扩容时被读线程感知

### 介绍 tcp http 和 https非对称和对称加密 为什么对称用的多

### 为什么mysql底层使用B+树

### 说一下Spring的事务机制

- Spring事务是基于数据库事务和AOP机制的
- 首先对于使用了@Transactional注解的Bean Spring会创建一个代理对象作为Bean
- 当调用代理对象的方法时 会先判断该方法上是否加了@Transactional注解
- 如果加了 那么则利用事务管理器创建一个数据库连接, 并且修改数据库连接的autocommit属性为false, 禁止此连接的自动提交
- 然后执行当前方法, 若方法没有出现异常则直接提交事务
- 若出现了异常, 并且这和异常是需要回滚的就会回滚事务, 否则仍然提交事务
- Spring事务的隔离级别对应的就是数据库的隔离级别
- Spring事务的传播机制是Spring事务自己实现的, 也是Spring事务最复杂的
- Spring事务的传播机制是基于数据库连接来做的, 一个数据连接一个事务; 如果传播机制配置为需要新开一个事务, 那么实际上就是先建立一个数据库连接, 在此新数据库连接上执行sql

### 什么时候@Transactional失效

- 因为Spring事务是基于代理来实现的, 所以某个加了@Transactional的方法只有是被代理对象调用时那么这个注解才会生效; 如果是被代理对象来调用这个方法, 那么@Transactional是不会生效的
- 若某个方法是private的, 那么@Transactional也不会生效, 因为底层cglib是基于继承来实现的, 子类是不能重写父类的private的方法的 所以无法很好的利用代理, 也会导致@Transactional失效
- rollbackFor = RuntimeException.class; 若出现的异常不属于rollbackFor中的异常, 则@Transactional失效

### 使用堆外内存的原因

- 对垃圾回收停顿的改善, 由于堆外内存是直接受操作系统管理而不是JVM, 所以使用堆外内存时可以保持较小的堆内内存规模, 从而在GC时减少回收停顿对应用的影响
- 提升程序I/O操作的性能, 通常在I/O通信过程中, 会存在堆内内存到堆外内存的数据拷贝动作, 对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据, 都建议储存到堆外内存

JDK8中使用元空间代替永久代的原因: 因为方法区所储存的类信息通常是比较难确定的, 所以对于方法区的大小是比较难指定的, 太小了容易出现方法区溢出, 太大了又会占用太多的虚拟机的内存空间, 干脆将方法区使用堆外内存实现

### 如何实现AOP 项目中那些地方用到了AOP

利用动态代理技术实现AOP

事务、权限管理、方法的执行时长日志都是通过AOP技术来实现的; 凡是需要对某些方法做统一处理的都可以使用AOP来实现, 利用AOP可以做到业务无入侵

AOP是在Bean生命周期中的初始化后阶段实现的

### Spring 中后置处理器的作用

Spring中的后置处理器分为 BeanFactoryPostProcessor 和 BeanPostProcessor; 它们是Spring底层源码架构设计中非常重要的一种机制, 同时开发者可以使用这两种后置处理器来进行扩展;

BeanFactoryPostProcessor表示针对 BeanFactory 的处理器, Spring处理过程中, 会先创建出BeanFactory实例, 然后利用BeanFactory处理器来加工BeanFactory; 比如Spring的扫描就是基于BeanFactoryPostProcessor来实现的

BeanPostProcessor表示针对Bean的处理器, Spring在创建一个Bean的过程中, 首先会实例化得到一个对象, 然后再利用BeanPostProcessor来对实例对象进行加工; 依赖注入就是基于一个BeanPostProcessor来实现的, 通过该BeanPostProcessor来给实例对象中加了@Autowired注解的属性自动赋值; AOP 也是利用一个BeanPostProcessor来实现的, 基于原实例对象, 判断是否需要进行AOP, 如果需要, 那么就基于原实例对象进行动态代理生成一个代理对象

### Redis集群策略

- 主从模式: 这种模式比较简单, 主库可以读写, 并且会和从库进行数据同步; 这种模式下客户端直接连接主库或者某个从库, 但是当主库或者从库宕机后, 客户端需要手动修改IP, 另外, 这种模式也比较难进行扩容, 整个集群所能储存的数据收到某台机器的内存容量的限制, 所以不可能支持特大数据量
- 哨兵模式: 这种模式在主从的基础上新增了哨兵节点, 当主库节点宕机后, 哨兵会发现主库节点宕机, 然后会在从库中选择一个作为新的主库; 另外哨兵也可以做集群, 从而可以保证当某一个哨兵节点宕机后 , 还有其他哨兵节点可以继续工作, 这种模式可以比较好的保证Redis集群的高可用, 但是仍然不能很好解决Redis的容量上限问题
- Cluster模式: Cluster模式是用的比较多的模式 它支持多主多从, 这种模式会按照key进行槽位的分配 可以使得不同的key分散到不同的主节点上, 利用这种模式可以使得整个集群支持更大的数据容量, 同时每个主节点可以拥有自己的多个从节点; 如果该主节点宕机, 会从它的从节点中选举一个新的主节点

### MySQL数据库中什么情况下设置了索引但无法使用

- 没有符合最左前缀原则
- 字段进行了隐式数据类型转化
- 走索引没有全表扫描效率高

### Innodb 是如何实现事务的

Innodb通过 Buffer Pool, LogBuffer, redo log, undo log 来实现事务

- Innodb 在收到一个update语句后, 会根据条件找到数据所在的页, 并将该页缓存在Buffer Pool中
- 执行update语句后, 修改Buffer Pool 中的数据, 也就是内存中的数据
- 针对update语句生成一个redo-log对象, 并存入LogBuffer中
- 针对update语句生成undo-log日志, 用于事务回滚
- 如果事务提交, 那么则把redo-log对象进行持久化, 后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
- 如果事务回滚, 则利用undo-log日志进行回滚

### 遇到过哪些设计模式

### Java 死锁如何避免

造成死锁的几个原因

- 一个资源每次只能被一个线程使用
- 一个线程在阻塞等待某个资源时, 不释放已占有资源
- 一个线程已经获得的资源, 在未使用完成之前, 不能被强行剥夺
- 若干线程形成头尾相接的循环等待资源关系

### 谈谈 ConcurrentHashMap的扩容机制 7 和 8 的区别

### Spring 中的 Bean是线程安全的吗

Spring本身并没有对Bean做线程安全的处理

如果 Bean是无状态的, 那么Bean就是线程安全的

如果 Bean是有状态的, 那么Bean就是线程不安全的

此外Bean是不是线程安全的和Bean的作用域没有关系, Bean的作用域只是表示Bean的生命周期范围, 对于任何生命周期的Bean都是一个对象

### Spring 中使用了哪些设计模式

- 工厂模式: BeanFactory; FactoryBean
- 适配器模式: AdvisorAdapter接口, 对Advisor进行了适配
- 访问者模式: PropertyAccessor接口: 属性访问器, 用来设置和访问某个对象的某个属性
- 装饰器模式: BeanWrapper
- 代理模式: AOP
- 观察者模式: 事件监听机制; Spring 事件驱动模型
- 策略模式: InstantiationStrategy 根据不同的情况进行实例化
- 模板模式: JdbcTemplate
- 委派模式: BeanDefinitionParserDelegate
- 责任链模式: BeanPostProcessor

### 消息队列如何保证消息可靠传输

### 强平衡二叉树和弱平衡二叉树有什么区别

强平衡二叉树即AVL树, 而弱平衡二叉树即红黑树

- AVL树比红黑树对于平衡的程度更加的严格, 在相同节点的情况下, AVL树的高度低于红黑树
- AVL树的旋转操作比红黑树的旋转操作更加耗时

### B树和B+树的区别 为什么MySQL使用B+树

B树的特点

- 节点排序
- 一个节点可以存多个元素, 且多个元素也是有序的

B+树的特点

- 拥有B树的特点
- 叶子节点之间有指针
- 非叶子节点上的元素在叶子节点上都有冗余, 即叶子节点中储存了所有的元素, 并且排好序

MySQL索引使用的是B+树; 在MySQL一个Innodb页就是一个B+树节点, 一个Innodb页默认为16k; B+树可以很好的支持全表扫描和范围查找等SQL语句

### epoll和poll的区别

- select模型: 使用的是数组来存储Socket连接文件描述符, 容量是固定的, 需要通过轮询来判断是否发生了IO事件(同步)
- poll模型: 使用的是链表来储存Socket连接文件描述符, 容量是不固定的, 同样需要通过轮询来判断是否发生了IO事件(同步)
- epoll模型: epoll和poll是完全不同的 epoll是一种事件通知模型(异步)

### HTTPS是是如何保证安全传输的

### 设计模式有哪些大类

创建型

- 工厂模式(Factory Pattern)
- 抽象工厂模式(Abstract Factory Pattern)
- 单例模式(Singleton Pattern)
- 建造者模式(Builder Pattern)
- 原型模式(Prototype Pattern)

结构型

- 适配器模式(Adapter Pattern)
- 桥接模式(Bridge Pattern)
- 过滤器模式(Filter、Criteria Pattern)
- 组合模式(Composite Pattern)
- 装饰器模式(Decorator Pattern)
- 外观模式(Facade Pattern)
- 享元模式(Flyweight Pattern)
- 代理模式(Proxy Pattern)

行为型

- 责任链模式(Chain of Responsibility Pattern)
- 命令模式(Command Pattern)
- 解释器模式(Interpreter Pattern)
- 迭代器模式(Iterator Pattern)
- 中介者模式(Mediator Pattern)
- 备忘录模式(Memento Pattern)
- 观察者模式(Observer Pattern)
- 状态模式(State Pattern)
- 空对象模式(Null Object Pattern)
- 策略模式(Strategy Pattern)
- 模板模式(Template Pattern)
- 访问者模式(Visitor Pattern)

### 设计模式的六大原则

开闭原则

里氏替换原则

依赖倒转原则

接口隔离原则

迪米特法则

合成复用原则

### 线程安全的理解

当多个线程访问一个对象时, 如果不用进行额外的同步控制或者其他的协调操作, 调用这个对象的行为获得的结果和在单线程下获得的结果保持一致, 那么就说这个对象是线程安全的

Thread和Runnable实质上是继承关系; 如果有复杂的线程操作需求, 那就选择继承Thread, 如果只是简单的执行一个任务, 那就实现Runnable

### ThreadLocal 的原理和使用场景

使用场景

- 线程间数据隔离
- 进行事务操作, 用于储存线程事务信息
- 数据库连接; session会话管理

Spring 框架在事务开始时会给当前线程绑定一个 Jdbc Connection, 在整个事务过程中都是使用该线程绑定的connection来执行数据库操作, 从而实现了事务的隔离性; Spring框架里面就是用的ThreadLocal来实现这种隔离

ThreadLocal内存泄漏问题

ThreadLocal内存泄漏的根源是由于ThreadLocalMap的生命周期和Thread一样长, 如果没手动删除对应key就会导致内存泄漏问题, 而并不是弱引用的问题

ThreadLocal 正确的使用方法

- 每次使用完ThreadLocal都调用它的remove方法
- 将ThreadLocal变量定义为private static, 这样就一直存在ThreadLocal的强引用, 也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值, 进而清除掉value的值

### 线程池中阻塞对队列的作用;为什么是先添加队列而不是先创建最大线程

一般的队列只能保证作为一个有限长度的缓冲区, 如果超出了缓冲长度就无法保留当前的任务了, 阻塞队列可以保留住当前想要继续入队的任务

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程, 使得线程进入wait状态, 释放cpu资源

阻塞队列自带的阻塞和唤醒功能, 不需要额外处理, 无任务执行时线程池利用阻塞队列的take方法挂起, 从而维持核心线程的存活, 不至于一直占用CPU资源

在创建线程的时候, 是要获取全局锁的, 这个时候其他的线程就得阻塞, 影响了整体效率

### 线程池中线程复用原理

线程池将线程和任务进行解耦; 线程是线程, 认为是任务, 摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制

### Spring 是什么

### BeanFactory 和 ApplicationContext 有什么区别

ApplicationContext是BeanFactory 的子接口

ApplicationContext 提供了更完整的功能

> 继承了MessageSource 因此支持国际化
>
> 统一的资源文件访问方式
>
> 提供了在监听器中注册bean的事件
>
> 同时加载多个配置文件
>
> 载入多个上下文, 使得每一个上下文都专注于一个特定的层次; 比如应用的web层

- BeanFactory 采用的是延迟加载的形式来注入Bean的, 即只有在使用到某个Bean时(调用getBean()) 才会对该Bean进行实例化; 如果Bean的某一个属性没有注入, BeanFactory 加载后直至第一次使用调用getBean方法才会抛出异常
- ApplicationContext 在容器启动时一次创建了所有的Bean
- ApplicationContext 启动后预载入了所有的单实例Bean, 当使用某个Bean时不用等待
- ApplicationContext 会占用内存空间, 当应用程序配置Bean较多时, 程序启动较慢
- BeanFactory 通常以编程的方式被创建, ApplicationContext还能以声明的方式创建, 如使用 ContextLoader
- BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor 和 BeanFactoryPostProcessor, 但是前者需要手动注册, 而后者则是自动注册

### 什么是字节码以及它的组成

Java 字节码 是 Java 虚拟机执行的一种指令格式

.class 文件是由十六进制值组成的, JVM以两个十六进制值为一组, 就是以字节为单位进行读取

- 魔数

- 版本号

- 常量池

  >常量池有两类常量: 字面量和符号引用
  >
  >常量池整体分为两个部分: 常量池计数器和常量池数据区

- 访问标志

- 当前类索引

- 父类索引

- 接口索引

- 字段表

- 方法表

- 附件属性







