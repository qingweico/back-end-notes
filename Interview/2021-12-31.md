[TOC]

## Java 基础

String类常用方法有哪些

Files类常用方法有哪些

throw 和 throws 的区别

Iterator 怎么使用 有哪些特点

NoClassDefFoundError和ClassNotFoundException的区别

### 什么是死锁 死锁产生的条件 如何避免死锁

形成死锁的四个必要条件

- 互斥条件: 一个资源每次只能被一个进程使用
- 请求与保持条件: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放
- 不剥夺条件: 进程已获得的资源, 在末使用完之前, 不能强行剥夺
- 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系

处理死锁

预防死锁: 破坏四个必要条件中的一个或多个来预防死锁

- 第一个条件 "互斥" 是不能破坏的, 因为加锁就是为了保证互斥
- 一次性申请所有的资源, 破坏 "占有且等待" 条件
- 占有部分资源的线程进一步申请其他资源时, 如果申请不到, 主动释放它占有的资源, 破坏 "不可 抢占" 条件
- 按序申请资源, 破坏 "循环等待" 条件

避免死锁: 在资源动态分配的过程中, 用某种方式防止系统进入不安全的状态

检测死锁: 运行时产生死锁, 及时发现死锁, 将程序解脱出来

解除死锁: 发生死锁后, 撤销进程, 回收资源, 分配给正在阻塞状态的进程

### 说一下HashMap和HashTable的区别吧

- HashMap的基类是AbstractMap, 基接口是Map; 而HashTable的基类是Dictionary, 基接口是Map
- HashMap的初始容量是16, 而HashTable的初始容量为11, 负载因子都是0.75; 但是扩容机制不同, HashMap是旧数组长度*2, 而HashTable是旧数组长度 * 2 + 1
- HashMap是线程不安全的, 而HashTable是线程安全的, 因为所有的方法都使用了synchronized
- HashMap使用迭代器迭代, Iterator基于fail-fast机制, 而HashTable可以使用迭代器和枚举
- HashMap的K和V都可以为null, 而HashTable中都不能为null
- HashMap遍历顺序为对数组从左往右遍历, 而HashTable则相反
- 计算理念不同: HashMap 为了性能, 尽量使用位运算; HashTable为了减少冲突, 使得元素位置更加均匀
- HashMap中取消了contains方法和elements方法, 使用containsKey和containsValue, 但是HashTable中四个方法都有
- 对象的定位方法不同
  - HashMap, 使用K的hashCode进行高低16位&运算作为hash值, 和数组的长度减一进行&运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - HashTable使用K的hashCode直接作为hash值和数组长度进行求余运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - 扩容的时候是2的n次方进行扩容, hash值在和2的n次方进行求余运算和&运算的结果一样, 但是&运算要快得多
  - 因为扩容倍数的特殊性, 导致扩容后不需要重新计算键值对在新数组的位置, 只需要判断K的hash值多出来的那一位是0还是1, 如果是0, 新表中键值对的位置和旧表一样, 如果是1 新表中键值对的位置等于旧表的位置 +  旧表的长度
- 关于快速失败 fail-fast: 说的是在juc下的非线程安全集合, (除了Stack、Vector、Enum、HashTable、Properties) 在迭代的过程中一旦别的线程对集合本身进行了结构性的修改(长度变化了), 那么迭代立刻结束, 迭代器将抛出ConcurrentModificationException, 而线程安全的集合和juc包下的集合都是safe-fail

## MQ

rabbitmq的使用场景有哪些

rabbitmq 有哪些重要的角色

rabbitmq 有哪些重要的组件

rabbitmq 中vhost 的作用是什么

rabbitmq 的消息是怎么发送的

rabbitmq 怎么保证消息的稳定性

rabbitmq 怎么避免消息丢失

消息持久化成功的条件有哪些

rabbitmq  持久化有什么缺点

rabbitmq  有几种广播类型

rabbitmq  节点的类型有哪些

rabbitmq  集群搭建需要注意哪些问题

rabbitmq  每个节点是其他节点的完整拷贝吗

rabbitmq  集群中唯一一个磁盘节点崩溃了会怎样

rabbitmq  对集群节点停止顺序有要求吗

消息队列如何保证消息可靠传输

## Redis

redis是什么 都有哪些使用场景

### redis 单线程问题

Redis 是单线程的, 主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的; 但 Redis的其他功能, 比如持久化, 异步删除, 集群数据同步等其实是由额外的线程执行的, 所以 Redis 严格来说并不是单线程的

Redis 为什么用单线程: 减少多线程带来的额外开销和多线程同时访问共享资源的并发问题

单线程 Redis 为什么那么快:

- Redis 大部分操作在内存上完成
- 采用了高效的数据结构
- 采用了 多路复用机制

### 基于多路复用的高性能 I/O模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流, 就是我们经常听到的 select/epoll 机制

该机制允许内核中, 同时存在多个监听套接字和已连接套接字, 内核会一直监听这些套接字上的连接请求或数据请求, 一旦有请求到达, 就会交给 Redis 线程处理, 这就实现了一个 Redis 线程处理多个 IO 流的效果

为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数

### Redis 基本 IO 模型, 还有哪些潜在的性能瓶颈

Redis单线程处理IO请求性能瓶颈主要包括2个方面: 

任意一个请求在server中一旦发生耗时, 都会影响整个server的性能, 也就是说后面的请求都要等前面这个耗时请求处理完成, 自己才能被处理到, 耗时的操作包括以下几种

- 操作bigkey: 写入一个bigkey在分配内存时需要消耗更多的时间, 同样, 删除bigkey释放内存同样会产生耗时;
- 使用复杂度过高的命令: 例如SORT/SUNION/ZUNIONSTORE, 或者O(N)命令, 但是N很大, 例如lrange key 0 -1一次查询全量数据
- 大量key集中过期: Redis的过期机制也是在主线程中执行的, 大量key集中过期会导致处理一个请求时, 耗时都在删除过期key, 耗时变长;
- 淘汰策略: 淘汰策略也是在主线程执行的, 当内存超过Redis内存上限后, 每次写入都需要淘汰一些key, 也会造成耗时变长
- AOF刷盘开启always机制: 每次写入都需要把这个操作刷到磁盘, 写磁盘的速度远比写内存慢，会拖慢Redis的性能；
- 主从全量同步生成RDB: 虽然采用fork子进程生成数据快照, 但fork这一瞬间也是会阻塞整个线程的, 实例越大, 阻塞时间越;

并发量非常大时, 单线程读写客户端IO数据存在性能瓶颈, 虽然采用IO多路复用机制, 但是读写客户端数据依旧是同步IO, 只能单线程依次读取客户端的数据, 无法利用到CPU多核。

针对问题1, 一方面需要业务人员去规避, 一方面Redis在4.0推出了lazy-free机制, 把bigkey释放内存的耗时操作放在了异步线程中执行, 降低对主线程的影响

针对问题2, Redis在6.0推出了多线程, 可以在高并发场景下利用CPU多核多线程读写客户端数据, 进一步提升server性能, 当然, 只是针对客户端的读写是并行的, 每个命令的真正操作依旧是单线程的

### 什么是缓存穿透 怎么解决

### redis 支持的数据类型有哪些

### redis 支持的java客户端有哪些

Redisson、Jedis、lettuce

### jedis 和 redisson 有哪些区别

### 怎么保证缓存和数据库数据一致性

redis 持久化有几种

redis 怎么实现分布式锁

redis 分布式锁有什么缺陷

redis 如何做内存优化

redis 淘汰策略有哪些

redis 常见的性能问题有哪些 怎么解决

### redis删除过期key的算法

- 惰性清除 在访问key时, 如果发现key已经过期, 那么会将key删除
- 定时清理
- 内存不够时清理

当执行写入命令时, 如果发现内存不够, 那么就会按照配置的淘汰策略清理内存

淘汰策略一般有6种, Redis4.0版本后又增加了2种, 主要由分为三类

第一类 不处理, 等报错(默认的配置)noeviction, 发现内存不够时, 不删除key, 执行写入命令时直接返回错误信息(Redis默认的配置就是noeviction)

第二类 从所有结果集中的key中挑选, 进行淘汰allkeys-random 就是从所有的key中随机挑选key, 进行淘汰; allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key, 进行淘汰; allkeys-lfu 就是从所有的key中挑选使用频率最低的key, 进行淘汰(这是Redis 4.0版本后新增的策略)

第三类 从设置了过期时间的key中挑选, 进行淘汰, 这种就是从设置了expires过期时间的结果集中选出一部分key淘汰, 挑选的算法有

-  volatile-random 从设置了过期时间的结果集中随机挑选key删除
- volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除
-  volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除)
- volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除(这是Redis 4.0版本后新增的策略)

### epoll和poll的区别

- select模型: 使用的是数组来存储Socket连接文件描述符, 容量是固定的, 需要通过轮询来判断是否发生了IO事件(同步)
- poll模型: 使用的是链表来储存Socket连接文件描述符, 容量是不固定的, 同样需要通过轮询来判断是否发生了IO事件(同步)
- epoll模型: epoll和poll是完全不同的 epoll是一种事件通知模型(异步)

### Redis集群策略

- 主从模式: 这种模式比较简单, 主库可以读写, 并且会和从库进行数据同步; 这种模式下客户端直接连接主库或者某个从库, 但是当主库或者从库宕机后, 客户端需要手动修改IP, 另外, 这种模式也比较难进行扩容, 整个集群所能储存的数据收到某台机器的内存容量的限制, 所以不可能支持特大数据量
- 哨兵模式: 这种模式在主从的基础上新增了哨兵节点, 当主库节点宕机后, 哨兵会发现主库节点宕机, 然后会在从库中选择一个作为新的主库; 另外哨兵也可以做集群, 从而可以保证当某一个哨兵节点宕机后 , 还有其他哨兵节点可以继续工作, 这种模式可以比较好的保证Redis集群的高可用, 但是仍然不能很好解决Redis的容量上限问题
- Cluster模式: Cluster模式是用的比较多的模式 它支持多主多从, 这种模式会按照key进行槽位的分配 可以使得不同的key分散到不同的主节点上, 利用这种模式可以使得整个集群支持更大的数据容量, 同时每个主节点可以拥有自己的多个从节点; 如果该主节点宕机, 会从它的从节点中选举一个新的主节点

## 并发

线程池有哪些状态

submit 和 execute 有哪些区别

#submit 

```java
 <T> Future<T> submit(Callable<T> task);
```

```java
 <T> Future<T> submit(Runnable task, T result);
```

```java
 Future<?> submit(Runnable task);
```

#execute 

```java
 void execute(Runnable command);
```

- execute 只能接受Runnable类型的任务
- execute 无返回值, 而submit有返回值
- execute 中的是 Runnable接口的实现, 所以只能使用try...catch来捕获受检异常;使用UncaughtExceptionHandler接口处理运行时异常;

多线程锁的升级原理是什么

什么是死锁

怎么防止死锁

说一下 ThreadLocal是什么 有哪些使用场景

synchronized 的底层实现原理

synchronized 和 volatile 的区别是什么

synchronized 和Lock 的区别是什么

### 线程安全的理解

当多个线程访问一个对象时, 如果不用进行额外的同步控制或者其他的协调操作, 调用这个对象的行为获得的结果和在单线程下获得的结果保持一致, 那么就说这个对象是线程安全的

Thread和Runnable实质上是继承关系; 如果有复杂的线程操作需求, 那就选择继承Thread, 如果只是简单的执行一个任务, 那就实现Runnable

### ThreadLocal 的原理和使用场景

使用场景

- 线程间数据隔离
- 进行事务操作, 用于储存线程事务信息
- 数据库连接; session会话管理

Spring 框架在事务开始时会给当前线程绑定一个 Jdbc Connection, 在整个事务过程中都是使用该线程绑定的connection来执行数据库操作, 从而实现了事务的隔离性; Spring框架里面就是用的ThreadLocal来实现这种隔离

ThreadLocal内存泄漏问题

ThreadLocal内存泄漏的根源是由于ThreadLocalMap的生命周期和Thread一样长, 如果没手动删除对应key就会导致内存泄漏问题, 而并不是弱引用的问题

ThreadLocal 正确的使用方法

- 每次使用完ThreadLocal都调用它的remove方法
- 将ThreadLocal变量定义为private static, 这样就一直存在ThreadLocal的强引用, 也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值, 进而清除掉value的值

### 线程池中阻塞对队列的作用;为什么是先添加队列而不是先创建最大线程

一般的队列只能保证作为一个有限长度的缓冲区, 如果超出了缓冲长度就无法保留当前的任务了, 阻塞队列可以保留住当前想要继续入队的任务

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程, 使得线程进入wait状态, 释放cpu资源

阻塞队列自带的阻塞和唤醒功能, 不需要额外处理, 无任务执行时线程池利用阻塞队列的take方法挂起, 从而维持核心线程的存活, 不至于一直占用CPU资源

在创建线程的时候, 是要获取全局锁的, 这个时候其他的线程就得阻塞, 影响了整体效率

### 线程池中线程复用原理

线程池将线程和任务进行解耦; 线程是线程, 任务是任务, 摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制

### ConcurrentHashMap原理7和8的区别

jdk1.7

数据结构: ReentrantLock + Segment + HashEntry 一个Segment中包含一个HashEntry数组 每个HashEntry数组中又是一个链表结构

元素查询: 二次hash 第一次hash定位到Segment 第二次hash定位到元素所在的链表的头部

锁: Segment继承至ReentrantLock 锁定操作的Segment 其他的Segment不受影响 并发粒度为segment个数 可以通过构造函数指定 数组扩容不会影响其他的segment

get方法无需加锁 volatile保证

jdk1.8

数据结构: Synchronized + CAS + Node + 红黑树 锁粒度更细 效率更高 

扩容时 阻塞所有的读写操作 并发扩容

写操作无锁 Node的val和next使用volatile修饰 读写线程对该变量可见

数组用volatile修饰 保证扩容时被读线程感知

## MySQL

char和varchar的区别

float和double的区别

mysql的内连接、左连接和右连接有什么区别

mysql 索引是怎么实现的

介绍下MySQL, B+树, 储存引擎

### Innodb 是如何实现事务的

Innodb通过 Buffer Pool, Log Buffer, redo log, undo log 来实现事务

- Innodb 在收到一个update语句后, 会根据条件找到数据所在的页, 并将该页缓存在Buffer Pool中
- 执行update语句后, 修改Buffer Pool 中的数据, 也就是内存中的数据
- 针对update语句生成一个redo-log对象, 并存入Log Buffer中
- 针对update语句生成undo-log日志, 用于事务回滚
- 如果事务提交, 那么则把redo-log对象进行持久化, 后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
- 如果事务回滚, 则利用undo-log日志进行回滚

### 强平衡二叉树和弱平衡二叉树有什么区别

强平衡二叉树即AVL树, 而弱平衡二叉树即红黑树

- AVL树比红黑树对于平衡的程度更加的严格, 在相同节点的情况下, AVL树的高度低于红黑树
- AVL树的旋转操作比红黑树的旋转操作更加耗时

### B树和B+树的区别 为什么MySQL使用B+树

B树的特点

- 节点排序
- 一个节点可以存多个元素, 且多个元素也是有序的

B+树的特点

- 拥有B树的特点
- 叶子节点之间有指针
- 非叶子节点上的元素在叶子节点上都有冗余, 即叶子节点中储存了所有的元素, 并且排好序

MySQL索引使用的是B+树; 在MySQL一个Innodb页就是一个B+树节点, 一个Innodb页默认为16k; B+树可以很好的支持全表扫描和范围查找等SQL语句

### MySQL数据库中什么情况下设置了索引但无法使用

- 没有符合最左前缀原则
- 字段进行了隐式数据类型转化
- 走索引没有全表扫描效率高

### 为什么mysql底层使用B+树

### 什么是索引 索引的优缺点 一般对哪些字段加索引

## Spring

### Spring 中的 Bean 是线程安全的吗

Spring本身并没有对Bean做线程安全的处理

如果 Bean是无状态的, 那么Bean就是线程安全的

如果 Bean是有状态的, 那么Bean就是线程不安全的

此外Bean是不是线程安全的和Bean的作用域没有关系, Bean的作用域只是表示Bean的生命周期范围, 对于任何生命周期的Bean都是一个对象

### Spring 中使用了哪些设计模式

- 工厂模式: BeanFactory; FactoryBean
- 适配器模式: AdvisorAdapter接口, 对Advisor进行了适配
- 访问者模式: PropertyAccessor接口: 属性访问器, 用来设置和访问某个对象的某个属性
- 装饰器模式: BeanWrapper
- 代理模式: AOP
- 观察者模式: 事件监听机制; Spring 事件驱动模型
- 策略模式: InstantiationStrategy 根据不同的情况进行实例化
- 模板模式: JdbcTemplate
- 委派模式: BeanDefinitionParserDelegate
- 责任链模式: BeanPostProcessor

### Spring中事务传播机制

- REQUIRED: 默认的传播特性; 如果没有事务, 则新建一个事务; 如果当前存在事务 则加入这个事务
- SUPPORTS: 当前存在事务, 则加入当前事务; 如果当前没有事务, 则以非事务的方式进行
- MANDATORY: 当前存在事务, 则加入当前事务; 如果当前事务不存在, 则抛出异常
- REQUIRED_NEW: 创建一个新事务; 如果存在当前事务, 则挂起当前事务
- NOT_SUPPORTED: 以非事务方式执行; 如果存在当前事务, 则挂起当前事务
- NEVER: 不使用事务; 如果当前事务存在, 则抛出异常
- NESTED: 如果当前事务存在, 则在嵌套事务中执行, 否则和REQUIRED的操作一样

### Spring 是什么

### BeanFactory 和 ApplicationContext 有什么区别

ApplicationContext是BeanFactory 的子接口

ApplicationContext 提供了更完整的功能

> 继承了MessageSource 因此支持国际化
>
> 统一的资源文件访问方式
>
> 提供了在监听器中注册bean的事件
>
> 同时加载多个配置文件
>
> 载入多个上下文, 使得每一个上下文都专注于一个特定的层次; 比如应用的web层

- BeanFactory 采用的是延迟加载的形式来注入Bean的, 即只有在使用到某个Bean时(调用getBean()) 才会对该Bean进行实例化; 如果Bean的某一个属性没有注入, BeanFactory 加载后直至第一次使用调用getBean方法才会抛出异常
- ApplicationContext 在容器启动时一次创建了所有的Bean
- ApplicationContext 启动后预载入了所有的单实例Bean, 当使用某个Bean时不用等待
- ApplicationContext 会占用内存空间, 当应用程序配置Bean较多时, 程序启动较慢
- BeanFactory 通常以编程的方式被创建, ApplicationContext还能以声明的方式创建, 如使用 ContextLoader
- BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor 和 BeanFactoryPostProcessor, 但是前者需要手动注册, 而后者则是自动注册

### @Bean 和 @Conponent 的区别

- 作用对象不同:  @Conponent作用于类 而@Bean作用于方法
- 使用方法不同: @Conponent 直接标注在类声明上即可, 而 @Bean 需要在配置类中(@Configuration)使用
- 实现不同: @Conponent 通常是通过类路径扫描(@ComponentScan)来自动装配到Spring容器中, 而 @Bean 通常在配置类中(@Configuration)定义产生Bean
- 灵活性不同: @Bean 比 @Conponent 更灵活, 比如需要注册第三方 Bean是只能通过 @Bean, 因为没有办法在第三方类库中添加 @Component注解

### 如何实现 AOP 项目中那些地方用到了AOP

利用动态代理技术实现AOP

事务、权限管理、方法的执行时长日志都是通过AOP技术来实现的; 凡是需要对某些方法做统一处理的都可以使用AOP来实现, 利用AOP可以做到业务无入侵

AOP是在Bean生命周期中的初始化后阶段实现的(AbstractAutoProxyCreator)

### Spring 中后置处理器的作用

Spring中的后置处理器分为 BeanFactoryPostProcessor 和 BeanPostProcessor; 它们是Spring底层源码架构设计中非常重要的一种机制, 同时开发者可以使用这两种后置处理器来进行扩展;

BeanFactoryPostProcessor表示针对 BeanFactory 的处理器, Spring处理过程中, 会先创建出BeanFactory实例, 然后利用BeanFactory处理器来加工BeanFactory; 比如Spring的扫描就是基于BeanFactoryPostProcessor来实现的

BeanPostProcessor表示针对Bean的处理器, Spring在创建一个Bean的过程中, 首先会实例化得到一个对象, 然后再利用BeanPostProcessor来对实例对象进行加工; 依赖注入就是基于一个BeanPostProcessor来实现的, 通过该BeanPostProcessor来给实例对象中加了@Autowired注解的属性自动赋值; AOP 也是利用一个BeanPostProcessor来实现的, 基于原实例对象, 判断是否需要进行AOP, 如果需要, 那么就基于原实例对象进行动态代理生成一个代理对象

### 说一下Spring的事务机制

- Spring事务是基于数据库事务和AOP机制的
- 首先对于使用了@Transactional注解的Bean Spring会创建一个代理对象作为Bean
- 当调用代理对象的方法时 会先判断该方法上是否加了@Transactional注解
- 如果加了 那么则利用事务管理器创建一个数据库连接, 并且修改数据库连接的autocommit属性为false, 禁止此连接的自动提交
- 然后执行当前方法, 若方法没有出现异常则直接提交事务
- 若出现了异常, 并且这和异常是需要回滚的就会回滚事务, 否则仍然提交事务
- Spring事务的隔离级别对应的就是数据库的隔离级别
- Spring事务的传播机制是Spring事务自己实现的, 也是Spring事务最复杂的
- Spring事务的传播机制是基于数据库连接来做的, 一个数据连接一个事务; 如果传播机制配置为需要新开一个事务, 那么实际上就是先建立一个数据库连接, 在此新数据库连接上执行sql

### 什么时候@Transactional失效

- 因为Spring事务是基于代理来实现的, 所以某个加了@Transactional的方法只有是被代理对象调用时那么这个注解才会生效; 如果是被代理对象来调用这个方法, 那么@Transactional是不会生效的
- 若某个方法是private的, 那么@Transactional也不会生效, 因为底层cglib是基于继承来实现的, 子类是不能重写父类的private的方法的 所以无法很好的利用代理, 也会导致@Transactional失效
- rollbackFor = RuntimeException.class; 若出现的异常不属于rollbackFor中的异常, 则@Transactional失效

## 网络

301 和 302 代表的是什么 有什么区别

说一下 tcp 粘包是怎样产生的

get 和 post 请求有哪些区别

http协议的header是什么结构

TCP 和 UDP 的区别

TCP如何实现拥塞控制的

TCP 怎么保证可靠传输

如果tcp断了 client怎么处理

单链表和双链表的区别以及应用场景

http 和 https 的区别

https 的加密过程

### 滑动窗口

TCP协议中，数据的发送方和接收方都会使用滑动窗口来控制数据的收发 有以下优点

- 避免等待
- 流量控制
- 效率高

滑动窗口的使用避免了数据重复校验，在字符串匹配等场合有多应用

一个窗口由两个标志位决定

- 左指针指向窗口的左边界
- 右指针指向窗口的右边界

在移动时, 按以下流程

- 固定左边界
- 右边界移动
- 当满足条件时, 移动左边界

###  http状态码有哪些

- 1XX: 信息状态码
- 2xx: 成功状态码
- 3xx: 重定向状态码
- 4xx: 客户端错误状态码
- 5xx: 服务端错误状态码

301 Moved Permanently: 永久性重定向

302 Found: 临时性重定向

303 See Other: 和302有着相同的功能, 但是303明确要求客户端应该采用GET方法获取资源

304 Not Modified: 如果请求报文首部包含一些条件, 例如:If-Match, If-Modified-Since, If-None- Match, If-Range, If-Unmodified-Since, 如果不满足条件, 则服务器会返回 304 状态码

307 Temporary Redirect: 临时重定向, 与302的含义类似, 但是307要求浏览器不会把重定向请求的POST方法改成GET方法

400 Bad Request: 请求报文中存在语法错误

401 Unauthorized: 该状态码表示发送的请求需要有认证信息

403 Forbidden: 请求被拒绝

404 Not Found

500 Internal Server Error: 服务器正在执行请求时发生错误

503 Service Unavailable: 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

###  输入一个url用到了哪些协议

### http协议由哪几部分组成

### HTTPS是是如何保证安全传输的

### 介绍 tcp http 和 https非对称和对称加密 为什么对称用的多

### 五层网络协议 七层网络协议

### 丢包发生在哪一层 为什么

### 如果电脑联网失败 是哪一层有问题 为什么

### 怎么发生丢包问题 ping命令 这个命令用到了哪些协议 ICMP协议 这个协议具体是怎么使用的

### 开机时操作系统的整个运转过程是怎样的

### 解释http协议 post和get的区别

### TCP和UDP的区别

### IP协议在哪一层 IP协议的作用

## JVM

### CMS和G1详细介绍一下

### 什么是字节码以及它的组成

Java 字节码 是 Java 虚拟机执行的一种指令格式

.class 文件是由十六进制值组成的, JVM以两个十六进制值为一组, 就是以字节为单位进行读取

- 魔数

- 版本号

- 常量池

  >常量池有两类常量: 字面量和符号引用
  >
  >常量池整体分为两个部分: 常量池计数器和常量池数据区

- 访问标志

- 当前类索引

- 父类索引

- 接口索引

- 字段表

- 方法表

- 附件属性

### 使用堆外内存的原因

- 对垃圾回收停顿的改善, 由于堆外内存是直接受操作系统管理而不是JVM, 所以使用堆外内存时可以保持较小的堆内内存规模, 从而在GC时减少回收停顿对应用的影响
- 提升程序I/O操作的性能, 通常在I/O通信过程中, 会存在堆内内存到堆外内存的数据拷贝动作, 对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据, 都建议储存到堆外内存

JDK8中使用元空间代替永久代的原因: 因为方法区所储存的类信息通常是比较难确定的, 所以对于方法区的大小是比较难指定的, 太小了容易出现方法区溢出, 太大了又会占用太多的虚拟机的内存空间, 干脆将方法区使用堆外内存实现

### 双亲委派模型的优势

## 框架

Spring 自动装配 bean 有哪些方式

Spring 实现事务方式有哪些

说一些 Spring MVC 的运行流程

Spring MVC 有哪些组件

Spring Boot 和 Spring 的区别

Spring Boot 的启动流程

不使用redis 存储session该怎么做

### cookie 和 session; session存储在服务端哪里

- 存储位置不同 cookie的数据信息存放在客户端浏览器上; session的数据信息存放在服务器上
- 存储容量不同 单个cookie保存的数据<=4KB, 一个站点最多保存20个Cookie; 对于session来说并没有上限, 但出于对服务器端的性能考虑, session内不要存放过多的东西, 并且设置session删除机制
- 存储方式不同 cookie中只能保管ASCII字符串, 并需要通过编码方式存储为Unicode字符或者二进制数据; session中能够存储任何类型的数据
- 隐私策略不同 cookie对客户端是可见的, 别有用心的人可以分析存放在本地的cookie并进行cookie欺骗, 所以它是不安全的; session存储在服务器上, 对客户端是透明对, 不存在敏感信息泄漏的风险
- 有效期上不同 开发可以通过设置cookie的属性, 达到使cookie长期有效的效果; session依赖于名为JSESSIONID的cookie, 而cookie JSESSIONID的过期时间默认为-1, 只需关闭窗口该session就会失效, 因而session不能达到长期有效的效果
- 服务器压力不同 cookie保管在客户端, 不占用服务器资源; session是保管在服务器端的, 每个用户都会产生一个session
- 浏览器支持不同 cookie是需要客户端浏览器支持的, 假如客户端禁用了cookie, 或者不支持cookie, 则会话跟踪会失效, 关于WAP上的应用, 常规的cookie就派不上用场了; 运用session需要使用URL地址重写的方式, 一切用到session程序的URL都要进行URL地址重写, 否则session会话跟踪还会失效
- 跨域支持上不同 cookie支持跨域名访问; session不支持跨域名访问

## 设计模式

### 设计模式有哪些大类

创建型

- 工厂模式(Factory Pattern)
- 抽象工厂模式(Abstract Factory Pattern)
- 单例模式(Singleton Pattern)
- 建造者模式(Builder Pattern)
- 原型模式(Prototype Pattern)

结构型

- 适配器模式(Adapter Pattern)
- 桥接模式(Bridge Pattern)
- 过滤器模式(Filter、Criteria Pattern)
- 组合模式(Composite Pattern)
- 装饰器模式(Decorator Pattern)
- 外观模式(Facade Pattern)
- 享元模式(Flyweight Pattern)
- 代理模式(Proxy Pattern)

行为型

- 责任链模式(Chain of Responsibility Pattern)
- 命令模式(Command Pattern)
- 解释器模式(Interpreter Pattern)
- 迭代器模式(Iterator Pattern)
- 中介者模式(Mediator Pattern)
- 备忘录模式(Memento Pattern)
- 观察者模式(Observer Pattern)
- 状态模式(State Pattern)
- 空对象模式(Null Object Pattern)
- 策略模式(Strategy Pattern)
- 模板模式(Template Pattern)
- 访问者模式(Visitor Pattern)

### 设计模式的六大原则

开闭原则

里氏替换原则

依赖倒转原则

接口隔离原则

迪米特法则

合成复用原则

## 算法

两个栈实现队列

打印二叉树的左边界

二叉树转双向链表

k个反转链表

最长重复子串

接雨水

滑动窗口 求数组中连续k个数的最大平均值 

二叉树的序列化和反序列化

加油站问题