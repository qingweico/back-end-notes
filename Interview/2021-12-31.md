[TOC]

## Java 基础

### String、StringBuffer、StringBuilder的区别

### JDK1.7和JDK1.8有哪些区别

编程语言

- Lambda表达式
- 方法引用
- 默认方法
- 可重复注解
- 类型注解: 在 Java8之前 注解只能出现在声明的地方所使用 比如类、方法、属性; 在Java8里面, 注解可以应用在任何地方
- 方法参数反射

集合

- Stream API
- HashMap优化

JVM

- 永久代移出

新的日期时间 API

并行(parallel)数组: Arrays::parallelSort([])

Base64编码

### String类常用方法有哪些

### Files类常用方法有哪些

### Iterator 怎么使用; 有哪些特点

### NoClassDefFoundError和ClassNotFoundException的区别

### ArrayList的扩容是怎么实现; 扩容过程中能不能继续进行 add 操作

### Java序列化了解吗; 什么是序列化; 有哪些方式; 如果自定义的话怎么做

### 序列化、反序列化的作用

### 用Iterator遍历Map

### Jason;Kryo;Hessian;ProtoBuf四种序列化算法的特点和差异; 看过怎么实现的吗

### 什么是死锁;死锁产生的条件;如何避免死锁

形成死锁的四个必要条件

- 互斥条件: 一个资源每次只能被一个进程使用
- 请求与保持条件: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放
- 不剥夺条件: 进程已获得的资源, 在末使用完之前, 不能强行剥夺
- 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系

处理死锁

预防死锁: 破坏四个必要条件中的一个或多个来预防死锁

- 第一个条件 "互斥" 是不能破坏的, 因为加锁就是为了保证互斥
- 一次性申请所有的资源, 破坏 "占有且等待" 条件
- 占有部分资源的线程进一步申请其他资源时, 如果申请不到, 主动释放它占有的资源, 破坏 "不可 抢占" 条件
- 按序申请资源, 破坏 "循环等待" 条件

避免死锁: 在资源动态分配的过程中, 用某种方式防止系统进入不安全的状态

检测死锁: 运行时产生死锁, 及时发现死锁, 将程序解脱出来

解除死锁: 发生死锁后, 撤销进程, 回收资源, 分配给正在阻塞状态的进程

### 使用反射创建实例和new一个对象的区别

### 说一下HashMap和HashTable的区别吧

- HashMap的基类是AbstractMap, 基接口是Map; 而HashTable的基类是Dictionary, 基接口是Map
- HashMap的初始容量是16, 而HashTable的初始容量为11, 负载因子都是0.75; 但是扩容机制不同, HashMap是旧数组长度*2, 而HashTable是旧数组长度 * 2 + 1
- HashMap是线程不安全的, 而HashTable是线程安全的, 因为所有的方法都使用了synchronized
- HashMap使用迭代器迭代, Iterator基于fail-fast机制, 而HashTable可以使用迭代器和枚举
- HashMap的K和V都可以为null, 而HashTable中都不能为null
- HashMap遍历顺序为对数组从左往右遍历, 而HashTable则相反
- 计算理念不同: HashMap 为了性能, 尽量使用位运算; HashTable为了减少冲突, 使得元素位置更加均匀
- HashMap中取消了contains方法和elements方法, 使用containsKey和containsValue, 但是HashTable中四个方法都有
- 对象的定位方法不同
  - HashMap, 使用K的hashCode进行高低16位&运算作为hash值, 和数组的长度减一进行&运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - HashTable使用K的hashCode直接作为hash值和数组长度进行求余运算, 得到键值对在数组中的位置, 然后再用equals方法形成链表
  - 扩容的时候是2的n次方进行扩容, hash值在和2的n次方进行求余运算和&运算的结果一样, 但是&运算要快得多
  - 因为扩容倍数的特殊性, 导致扩容后不需要重新计算键值对在新数组的位置, 只需要判断K的hash值多出来的那一位是0还是1, 如果是0, 新表中键值对的位置和旧表一样, 如果是1 新表中键值对的位置等于旧表的位置 +  旧表的长度
- 关于快速失败 fail-fast: 说的是在juc下的非线程安全集合, (除了Stack、Vector、Enum、HashTable、Properties) 在迭代的过程中一旦别的线程对集合本身进行了结构性的修改(长度变化了), 那么迭代立刻结束, 迭代器将抛出ConcurrentModificationException, 而线程安全的集合和juc包下的集合都是safe-fail

### 进程和线程

### 说一下什么是进程;什么是线程

### 进程和线程之间的区别是什么

### 线程和进程之间的通信方式有哪些

### 进程间的通信方式

- 管道
- 消息队列
- 信号量
- 共享内存
- 套接字

### 能举例说一下信号量的使用吗

### 共享内存算在进程的内存占用中吗

### git中pull和fetch的区别

git pull看起来像git fetch+git merge

### socket 和 channel的区别

### IO多路复用讲一下

### select描述符限制是多少(1024); 为什么是1024

### 僵尸进程概念;如何解决

一个进程在调用exit命令结束自己的生命的时候, 其实它并没有真正的被销毁,  而是留下一个称为僵尸进程(Zombie)的数据结构(系统调用exit, 它的作用是 使进程退出, 但也仅仅限于将一个正常的进程变成一个僵尸进程, 并不能将其完全销毁)

- 父进程通过wait和waitpid等函数等待子进程结束, 这会导致父进程挂起
- 如果父进程很忙, 那么可以用signal函数为SIGCHLD安装handler, 因为子进程结束后,  父进程会收到该信号, 可以在handler中调用wait回收
-  如果父进程不关心子进程什么时候结束, 那么可以用signal(SIGCHLD,SIG_IGN) 通知内核, 自己对子进程的结束不感兴趣, 那么子进程结束后, 内核会回收,  并不再给父进程发送信号
-  还有一些技巧, 就是[fork](http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7618891)两次, 父进程fork一个子进程, 然后继续工作, 子进程fork一 个孙进程后退出, 那么孙进程被[init](http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7727069)接管, 孙进程结束后, init会回收; 不过子进程的回收 还要自己做

### 孤儿进程概念

在操作系统领域中, 孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程; 这些孤儿进程将被init进程(进程号为1)所收养, 并由init进程对它们完成状态收集工作

### 如果是一个服务器用于存储数据; 然后里面有一些数据是热点数据; 需要缓存; 用哪种引用

热点数据缓存是用软引用

### 匿名内部类如何持有外部类对象

类和内部类的关系; 内部类为什么可以访问外部类的私有属性

### 内存泄漏的场景

### 内存泄漏的概念

### main方法执行之前发生了什么

### 线程的从用户态和核心态的具体过程是什么

### finalize 的作用

### BIO, NIO, 和AIO都了解哪些, 各种IO讲一下

## MQ

rabbitmq的使用场景有哪些

rabbitmq 有哪些重要的角色

rabbitmq 有哪些重要的组件

rabbitmq 中vhost 的作用是什么

rabbitmq 的消息是怎么发送的

rabbitmq 怎么保证消息的稳定性

rabbitmq 怎么避免消息丢失

消息持久化成功的条件有哪些

rabbitmq  持久化有什么缺点

rabbitmq  有几种广播类型

rabbitmq  节点的类型有哪些

rabbitmq  集群搭建需要注意哪些问题

rabbitmq  每个节点是其他节点的完整拷贝吗

rabbitmq  集群中唯一一个磁盘节点崩溃了会怎样

rabbitmq  对集群节点停止顺序有要求吗

消息队列如何保证消息可靠传输

## Redis

### redis是什么; 都有哪些使用场景

### redis 单线程问题

Redis 是单线程的, 主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的; 但 Redis的其他功能, 比如持久化, 异步删除, 集群数据同步等其实是由额外的线程执行的, 所以 Redis 严格来说并不是单线程的

Redis 为什么用单线程: 减少多线程带来的额外开销和多线程同时访问共享资源的并发问题

单线程 Redis 为什么那么快:

- Redis 大部分操作在内存上完成
- 采用了高效的数据结构
- 采用了 多路复用机制

### 基于多路复用的高性能 I/O模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流, 就是我们经常听到的 select/epoll 机制

该机制允许内核中, 同时存在多个监听套接字和已连接套接字, 内核会一直监听这些套接字上的连接请求或数据请求, 一旦有请求到达, 就会交给 Redis 线程处理, 这就实现了一个 Redis 线程处理多个 IO 流的效果

为了在请求到达时能通知到 Redis 线程, select/epoll 提供了基于事件的回调机制, 即针对不同事件的发生, 调用相应的处理函数

### Redis 基本 IO 模型, 还有哪些潜在的性能瓶颈

Redis单线程处理IO请求性能瓶颈主要包括2个方面: 

任意一个请求在server中一旦发生耗时, 都会影响整个server的性能, 也就是说后面的请求都要等前面这个耗时请求处理完成, 自己才能被处理到, 耗时的操作包括以下几种

- 操作bigkey: 写入一个bigkey在分配内存时需要消耗更多的时间, 同样, 删除bigkey释放内存同样会产生耗时;
- 使用复杂度过高的命令: 例如SORT/SUNION/ZUNIONSTORE, 或者O(N)命令, 但是N很大, 例如lrange key 0 -1一次查询全量数据
- 大量key集中过期: Redis的过期机制也是在主线程中执行的, 大量key集中过期会导致处理一个请求时, 耗时都在删除过期key, 耗时变长;
- 淘汰策略: 淘汰策略也是在主线程执行的, 当内存超过Redis内存上限后, 每次写入都需要淘汰一些key, 也会造成耗时变长
- AOF刷盘开启always机制: 每次写入都需要把这个操作刷到磁盘, 写磁盘的速度远比写内存慢, 会拖慢Redis的性能；
- 主从全量同步生成RDB: 虽然采用fork子进程生成数据快照, 但fork这一瞬间也是会阻塞整个线程的, 实例越大, 阻塞时间越;

并发量非常大时, 单线程读写客户端IO数据存在性能瓶颈, 虽然采用IO多路复用机制, 但是读写客户端数据依旧是同步IO, 只能单线程依次读取客户端的数据, 无法利用到CPU多核; 

针对问题1, 一方面需要业务人员去规避, 一方面Redis在4.0推出了lazy-free机制, 把bigkey释放内存的耗时操作放在了异步线程中执行, 降低对主线程的影响

针对问题2, Redis在6.0推出了多线程, 可以在高并发场景下利用CPU多核多线程读写客户端数据, 进一步提升server性能, 当然, 只是针对客户端的读写是并行的, 每个命令的真正操作依旧是单线程的

### 什么是缓存穿透; 怎么解决

缓存穿透是指查询⼀个⼀定不存在的数据, 由于缓存不命中时需要从数据库查询, 查不到数据则不写⼊缓存, 这 将导致这个不存在的数据每次请求都要到数据库去查询, 造成缓存穿透

缓存空对象：如果⼀个查询返回的数据为空(不管是数据不存在, 还是系统故障), 我们仍然把这个空结果进 ⾏缓存, 但它的过期时间会很短, 最⻓不超过五分钟

空值做了缓存, 意味着缓存中存了更多的键, 需要更多的内存空间, ⽐较有效的⽅法是针对这类数据设置⼀个 较短的过期时间, 让其⾃动剔除;  2. 缓存和存储的数据会有⼀段时间窗⼝的不⼀致, 可能会对业务有⼀定影响; 例如：过期时间设置为 5分钟, 如 果此时存储添加了这个数据, 那此段时间就会出现缓存和存储数据的不⼀致, 此时可以利⽤消息系统或者其他 ⽅式清除掉缓存层中的空对象

布隆过滤器：将所有可能存在的数据哈希到⼀个⾜够⼤的 bitmap 中, ⼀个⼀定不存在的数据会被这个 bitmap 拦截掉, 从⽽避免了对底层存储系统的查询压⼒

### redis 支持的数据类型有哪些

### redis 支持的java客户端有哪些

Redisson、Jedis、lettuce

### jedis 和 redisson 有哪些区别

### 怎么保证缓存和数据库数据一致性

### redis 持久化有几种

### redis 怎么实现分布式锁

### redis 分布式锁有什么缺陷

- 锁未被释放
- B的锁被A给释放了
- 数据库事务超时
- 锁过期了, 业务还没执行完
- redis主从复制

### redis 如何做内存优化

### redis 淘汰策略有哪些

### redis 常见的性能问题有哪些 怎么解决

### redis删除过期key的算法

- 惰性清除 在访问key时, 如果发现key已经过期, 那么会将key删除
- 定时清理
- 定期删除
- 内存不够时清理

当执行写入命令时, 如果发现内存不够, 那么就会按照配置的淘汰策略清理内存

淘汰策略一般有6种, Redis4.0版本后又增加了2种, 主要由分为三类

第一类 不处理, 等报错(默认的配置)noeviction, 发现内存不够时, 不删除key, 执行写入命令时直接返回错误信息(Redis默认的配置就是noeviction)

第二类 从所有结果集中的key中挑选, 进行淘汰allkeys-random 就是从所有的key中随机挑选key, 进行淘汰; allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key, 进行淘汰; allkeys-lfu 就是从所有的key中挑选使用频率最低的key, 进行淘汰(这是Redis 4.0版本后新增的策略)

第三类 从设置了过期时间的key中挑选, 进行淘汰, 这种就是从设置了expires过期时间的结果集中选出一部分key淘汰, 挑选的算法有

-  volatile-random 从设置了过期时间的结果集中随机挑选key删除
- volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除
-  volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除)
- volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除(这是Redis 4.0版本后新增的策略)

### epoll和poll的区别

- select模型: 使用的是数组来存储Socket连接文件描述符, 容量是固定的, 需要通过轮询来判断是否发生了IO事件(同步)
- poll模型: 使用的是链表来储存Socket连接文件描述符, 容量是不固定的, 同样需要通过轮询来判断是否发生了IO事件(同步)
- epoll模型: epoll和poll是完全不同的 epoll是一种事件通知模型(异步)

### Redis集群策略

- 主从模式: 这种模式比较简单, 主库可以读写, 并且会和从库进行数据同步; 这种模式下客户端直接连接主库或者某个从库, 但是当主库或者从库宕机后, 客户端需要手动修改IP, 另外, 这种模式也比较难进行扩容, 整个集群所能储存的数据收到某台机器的内存容量的限制, 所以不可能支持特大数据量
- 哨兵模式: 这种模式在主从的基础上新增了哨兵节点, 当主库节点宕机后, 哨兵会发现主库节点宕机, 然后会在从库中选择一个作为新的主库; 另外哨兵也可以做集群, 从而可以保证当某一个哨兵节点宕机后 , 还有其他哨兵节点可以继续工作, 这种模式可以比较好的保证Redis集群的高可用, 但是仍然不能很好解决Redis的容量上限问题
- Cluster模式: Cluster模式是用的比较多的模式 它支持多主多从, 这种模式会按照key进行槽位的分配 可以使得不同的key分散到不同的主节点上, 利用这种模式可以使得整个集群支持更大的数据容量, 同时每个主节点可以拥有自己的多个从节点; 如果该主节点宕机, 会从它的从节点中选举一个新的主节点

### 在集群模式下, Redis 的 key 是如何寻址的

### 分布式寻址都有哪些算法; 说一下一致性 hash

- hash 算法(大量缓存重建)
- 一致性 hash 算法(自动缓存迁移)+ 虚拟节点(自动负载均衡)
- redis cluster 的 hash slot 算法

### Redis 的并发竞争问题是什么; 如何解决这个问题

### 了解 Redis 事务的 CAS 方案吗

### zset底层; 为什么底层要同时使用哈希表+跳表的结构

### 讲一下跳表的结构

### redis 数据结构

### redis怎么保证和数据库数据一致性

### redis缓存到了过期时间是怎么删除缓存的

### 了解redis的哨兵模式吗

### redis 的sentinel原理能介绍一下么

### 知道redis里面可以设置到期时间吗; 底层是怎么实现的

## 并发

### 线程池有哪些状态

### 线程池的运行过程

### 怎么实现阻塞队列

### submit 和 execute 有哪些区别

#submit 

```java
 <T> Future<T> submit(Callable<T> task);
```

```java
 <T> Future<T> submit(Runnable task, T result);
```

```java
 Future<?> submit(Runnable task);
```

#execute 

```java
 void execute(Runnable command);
```

- execute 只能接受Runnable类型的任务
- execute 无返回值, 而submit有返回值
- execute 中的是 Runnable接口的实现, 所以只能使用try...catch来捕获受检异常;使用UncaughtExceptionHandler接口处理运行时异常;

### 多线程锁的升级原理是什么

### 说一下 ThreadLocal是什么 有哪些使用场景

### synchronized 的底层实现原理

### synchronized 和 volatile 的区别是什么

### synchronized 和Lock 的区别是什么

### 线程安全的理解

当多个线程访问一个对象时, 如果不用进行额外的同步控制或者其他的协调操作, 调用这个对象的行为获得的结果和在单线程下获得的结果保持一致, 那么就说这个对象是线程安全的

Thread和Runnable实质上是继承关系; 如果有复杂的线程操作需求, 那就选择继承Thread, 如果只是简单的执行一个任务, 那就实现Runnable

### ThreadLocal 的原理和使用场景

使用场景

- 线程间数据隔离
- 进行事务操作, 用于储存线程事务信息
- 数据库连接; session会话管理

Spring 框架在事务开始时会给当前线程绑定一个 Jdbc Connection, 在整个事务过程中都是使用该线程绑定的connection来执行数据库操作, 从而实现了事务的隔离性; Spring框架里面就是用的ThreadLocal来实现这种隔离

ThreadLocal内存泄漏问题

ThreadLocal内存泄漏的根源是由于ThreadLocalMap的生命周期和Thread一样长, 如果没手动删除对应key就会导致内存泄漏问题, 而并不是弱引用的问题

ThreadLocal 正确的使用方法

- 每次使用完ThreadLocal都调用它的remove方法
- 将ThreadLocal变量定义为private static, 这样就一直存在ThreadLocal的强引用, 也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值, 进而清除掉value的值

### 线程池中阻塞对队列的作用;为什么是先添加队列而不是先创建最大线程

一般的队列只能保证作为一个有限长度的缓冲区, 如果超出了缓冲长度就无法保留当前的任务了, 阻塞队列可以保留住当前想要继续入队的任务

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程, 使得线程进入wait状态, 释放cpu资源

阻塞队列自带的阻塞和唤醒功能, 不需要额外处理, 无任务执行时线程池利用阻塞队列的take方法挂起, 从而维持核心线程的存活, 不至于一直占用CPU资源

在创建线程的时候, 是要获取全局锁的, 这个时候其他的线程就得阻塞, 影响了整体效率

### 线程池中线程复用原理

线程池将线程和任务进行解耦; 线程是线程, 任务是任务, 摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制

### ConcurrentHashMap原理7和8的区别

jdk1.7

数据结构: ReentrantLock + Segment + HashEntry 一个Segment中包含一个HashEntry数组 每个HashEntry数组中又是一个链表结构

元素查询: 二次hash 第一次hash定位到Segment 第二次hash定位到元素所在的链表的头部

锁: Segment继承至ReentrantLock 锁定操作的Segment 其他的Segment不受影响 并发粒度为segment个数 可以通过构造函数指定 数组扩容不会影响其他的segment

get方法无需加锁 volatile保证

jdk1.8

数据结构: Synchronized + CAS + Node + 红黑树 锁粒度更细 效率更高 

扩容时 阻塞所有的读写操作 并发扩容

写操作无锁 Node的val和next使用volatile修饰 读写线程对该变量可见

数组用volatile修饰 保证扩容时被读线程感知

### synchronized 锁升级的过程

### synchronized在jdk1.8做了哪些优化？

### synchronized为什么要设计成可重入

### mesi协议

### volitale与synchronized的区别

### 如果异步请求需要保障成功, 怎么做

### 有时候多线程, 只需要一个执行, 就是幂等性校验怎么做

## MySQL

### char和varchar的区别

### float和double的区别

- 在内存中占有的字节数不同, 单精度内存占4个字节, 双精度内存占8个字节
- 有效数字位数不同(尾数) 单精度小数点后有效位数7位, 双精度小数点后有效位数16位
- 数值取值范围不同 根据IEEE标准来计算
- 在程序中处理速度不同,一般来说, CPU处理单精度浮点数的速度比处理双精度浮点数快

### mysql的内连接、左连接和右连接有什么区别

### mysql 索引是怎么实现的

### 介绍下MySQL, B+树, 储存引擎

### mysql如何保证ACID

从数据库层面, 数据库通过原子性、隔离性、持久性来保证一致性

原子性: undo log名为回滚日志, 是实现原子性的关键

持久性: redo log

隔离性: 锁和MVCC机制

### Innodb 是如何实现事务的

Innodb通过 Buffer Pool, Log Buffer, redo log, undo log 来实现事务

- Innodb 在收到一个update语句后, 会根据条件找到数据所在的页, 并将该页缓存在Buffer Pool中
- 执行update语句后, 修改Buffer Pool 中的数据, 也就是内存中的数据
- 针对update语句生成一个redo log对象, 并存入Log Buffer中
- 针对update语句生成undo log日志, 用于事务回滚
- 如果事务提交, 那么则把redo log对象进行持久化, 后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
- 如果事务回滚, 则利用undo log日志进行回滚

### 强平衡二叉树和弱平衡二叉树有什么区别

强平衡二叉树即AVL树, 而弱平衡二叉树即红黑树

- AVL树比红黑树对于平衡的程度更加的严格, 在相同节点的情况下, AVL树的高度低于红黑树
- AVL树的旋转操作比红黑树的旋转操作更加耗时

### B树和B+树的区别; 为什么MySQL使用B+树

B树的特点

- 节点排序
- 一个节点可以存多个元素, 且多个元素也是有序的

B+树的特点

- 拥有B树的特点
- 叶子节点之间有指针
- 非叶子节点上的元素在叶子节点上都有冗余, 即叶子节点中储存了所有的元素, 并且排好序

MySQL索引使用的是B+树; 在MySQL一个Innodb页就是一个B+树节点, 一个Innodb页默认为16k; B+树可以很好的支持全表扫描和范围查找等SQL语句

### MySQL数据库中什么情况下设置了索引但无法使用

- 没有符合最左前缀原则
- 字段进行了隐式数据类型转化
- 走索引没有全表扫描效率高

### 什么是索引; 索引的优缺点 一般对哪些字段加索引

### binlog 格式

###  MVCC原理说一下

### 最左前缀原则; 为什么要遵守最左前缀原则呢

### 乐观锁、悲观锁, 哪里使用到了

### 哈希索引的使用场景？如何让哈希索引实现范围查找？还能提供优化的方案吗

### explain的字段

### 查询sql语句的执行过程

### 更新sql语句的执行过程

### 什么是crash-safe

### MySQL实现crash-safe的原理

### 两阶段提交的方式会存在什么问题？解决方法

### 假设事务提交过程中, MySQL进程突然奔溃, 重启后是怎么保证数据不丢失的	

### 设一行数据的大小是1k, 在InnoDB中一个3层B+树最多大概可以存放多少行数数据; 主键ID为bigint(8B)类型

### MySQL中哪些情况下会发生死锁

### 如何解决死锁

超时等待、wait-for graph

### 如何避免死锁的发生

### 如何检查是否发生了死锁

死锁日志

### 添加索引时需要注意什么; 什么情况下不适合添加索引

### mysql状态码

### redo log和undo log是如何生成的

### 如何实现可重复读

### 如何解决幻读

### 间隙锁和next-key锁

### mysql锁是锁的什么

索引

### 怎么实现数据库的一致性

### 了解binlog吗; 知道binlog的底层吗; binlog里面具体记录是什么东西

## Spring

### Spring 中的 Bean 是线程安全的吗

Spring本身并没有对Bean做线程安全的处理

如果 Bean是无状态的, 那么Bean就是线程安全的

如果 Bean是有状态的, 那么Bean就是线程不安全的

此外Bean是不是线程安全的和Bean的作用域没有关系, Bean的作用域只是表示Bean的生命周期范围, 对于任何生命周期的Bean都是一个对象

### Spring 中使用了哪些设计模式

- 工厂模式: BeanFactory; FactoryBean
- 适配器模式: AdvisorAdapter接口, 对Advisor进行了适配
- 访问者模式: PropertyAccessor接口: 属性访问器, 用来设置和访问某个对象的某个属性
- 装饰器模式: BeanWrapper
- 代理模式: AOP
- 观察者模式: 事件监听机制; Spring 事件驱动模型
- 策略模式: InstantiationStrategy 根据不同的情况进行实例化
- 模板模式: JdbcTemplate
- 委派模式: BeanDefinitionParserDelegate
- 责任链模式: BeanPostProcessor

### Spring中事务传播机制

- REQUIRED: 默认的传播特性; 如果没有事务, 则新建一个事务; 如果当前存在事务 则加入这个事务
- SUPPORTS: 当前存在事务, 则加入当前事务; 如果当前没有事务, 则以非事务的方式进行
- MANDATORY: 当前存在事务, 则加入当前事务; 如果当前事务不存在, 则抛出异常
- REQUIRED_NEW: 创建一个新事务; 如果存在当前事务, 则挂起当前事务
- NOT_SUPPORTED: 以非事务方式执行; 如果存在当前事务, 则挂起当前事务
- NEVER: 不使用事务; 如果当前事务存在, 则抛出异常
- NESTED: 如果当前事务存在, 则在嵌套事务中执行, 否则和REQUIRED的操作一样

### Spring 是什么

### BeanFactory 和 ApplicationContext 有什么区别

ApplicationContext是BeanFactory 的子接口

ApplicationContext 提供了更完整的功能

> 继承了MessageSource 因此支持国际化
>
> 统一的资源文件访问方式
>
> 提供了在监听器中注册bean的事件
>
> 同时加载多个配置文件
>
> 载入多个上下文, 使得每一个上下文都专注于一个特定的层次; 比如应用的web层

- BeanFactory 采用的是延迟加载的形式来注入Bean的, 即只有在使用到某个Bean时(调用getBean()) 才会对该Bean进行实例化; 如果Bean的某一个属性没有注入, BeanFactory 加载后直至第一次使用调用getBean方法才会抛出异常
- ApplicationContext 在容器启动时一次创建了所有的Bean
- ApplicationContext 启动后预载入了所有的单实例Bean, 当使用某个Bean时不用等待
- ApplicationContext 会占用内存空间, 当应用程序配置Bean较多时, 程序启动较慢
- BeanFactory 通常以编程的方式被创建, ApplicationContext还能以声明的方式创建, 如使用 ContextLoader
- BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor 和 BeanFactoryPostProcessor, 但是前者需要手动注册, 而后者则是自动注册

### @Bean 和 @Conponent 的区别

- 作用对象不同:  @Conponent作用于类 而@Bean作用于方法
- 使用方法不同: @Conponent 直接标注在类声明上即可, 而 @Bean 需要在配置类中(@Configuration)使用
- 实现不同: @Conponent 通常是通过类路径扫描(@ComponentScan)来自动装配到Spring容器中, 而 @Bean 通常在配置类中(@Configuration)定义产生Bean
- 灵活性不同: @Bean 比 @Conponent 更灵活, 比如需要注册第三方 Bean是只能通过 @Bean, 因为没有办法在第三方类库中添加 @Component注解

### 如何实现 AOP; 项目中那些地方用到了AOP

利用动态代理技术实现AOP

事务、权限管理、方法的执行时长日志都是通过AOP技术来实现的; 凡是需要对某些方法做统一处理的都可以使用AOP来实现, 利用AOP可以做到业务无入侵

AOP是在Bean生命周期中的初始化后阶段实现的(AbstractAutoProxyCreator)

### Spring 中后置处理器的作用

Spring中的后置处理器分为 BeanFactoryPostProcessor 和 BeanPostProcessor; 它们是Spring底层源码架构设计中非常重要的一种机制, 同时开发者可以使用这两种后置处理器来进行扩展;

BeanFactoryPostProcessor表示针对 BeanFactory 的处理器, Spring处理过程中, 会先创建出BeanFactory实例, 然后利用BeanFactory处理器来加工BeanFactory; 比如Spring的扫描就是基于BeanFactoryPostProcessor来实现的

BeanPostProcessor表示针对Bean的处理器, Spring在创建一个Bean的过程中, 首先会实例化得到一个对象, 然后再利用BeanPostProcessor来对实例对象进行加工; 依赖注入就是基于一个BeanPostProcessor来实现的, 通过该BeanPostProcessor来给实例对象中加了@Autowired注解的属性自动赋值; AOP 也是利用一个BeanPostProcessor来实现的, 基于原实例对象, 判断是否需要进行AOP, 如果需要, 那么就基于原实例对象进行动态代理生成一个代理对象

### 说一下Spring的事务机制

- Spring事务是基于数据库事务和AOP机制的
- 首先对于使用了@Transactional注解的Bean Spring会创建一个代理对象作为Bean
- 当调用代理对象的方法时 会先判断该方法上是否加了@Transactional注解
- 如果加了 那么则利用事务管理器创建一个数据库连接, 并且修改数据库连接的autocommit属性为false, 禁止此连接的自动提交
- 然后执行当前方法, 若方法没有出现异常则直接提交事务
- 若出现了异常, 并且这和异常是需要回滚的就会回滚事务, 否则仍然提交事务
- Spring事务的隔离级别对应的就是数据库的隔离级别
- Spring事务的传播机制是Spring事务自己实现的, 也是Spring事务最复杂的
- Spring事务的传播机制是基于数据库连接来做的, 一个数据连接一个事务; 如果传播机制配置为需要新开一个事务, 那么实际上就是先建立一个数据库连接, 在此新数据库连接上执行sql

### 什么时候@Transactional失效

- 因为Spring事务是基于代理来实现的, 所以某个加了@Transactional的方法只有是被代理对象调用时那么这个注解才会生效; 如果是被代理对象来调用这个方法, 那么@Transactional是不会生效的
- 若某个方法是private的, 那么@Transactional也不会生效, 因为底层cglib是基于继承来实现的, 子类是不能重写父类的private的方法的 所以无法很好的利用代理, 也会导致@Transactional失效
- rollbackFor = RuntimeException.class; 若出现的异常不属于rollbackFor中的异常, 则@Transactional失效

### Spirng AOP 什么时候会失效

### BeanFactory和FactoryBean

### Spring怎么管理 Bean 的

### Spring发展历程

### 在Bean初始化前后做扩展, 需要怎么做

### BeanFactoryPostProcessor有了解吗

### Spring做消息监听怎么搞; 用的是哪些接口

### Spring 中的 AOP 底层实现原理

### Spring 中的 IOC 底层实现原理

### Spring 中Bean的注入方式有几种

- 使用  xml 的方式
- 使用@ComponentScan注解来扫描声明了@Controller @Service @Repository @Component注解的类
- 使用@Configuration注解声明配置类 并使用@Bean注解实现Bean的定义 这种方式其实是xml配置方式的以一种演变，是Spring迈入到无配置化时代的里程牌
- 使用@Import注解 导入配置类或者普通的Bean
- 使用FactoryBean工厂bean 动态构建一个Bean实例 Spring Cloud OpenFeign里面的动态代理实例就是使用FactoryBean来实现的
- 实现ImportBeanDefinitionRegistrar接口 可以动态注入Bean实例 在Spring Boot 里面的启动注解中用到
- 实现ImportSelector接口 动态批量注入配置类或者Bean对象 在Spring Boot里面的自动装配机制里面有用到

## 网络

### 301 和 302 代表的是什么 有什么区别

301 Moved Permanently: 永久性重定向

302 Found: 临时性重定向

### 说一下 TCP粘包是怎样产生的

发送方发送的多个数据包, 到接收方缓冲区首尾相连, 粘成一包, 被接收

原因: TCP 协议默认使用 Nagle 算法可能会把多个数据包一次发送到接收方, 应用程读取缓存中的数据包的速度小于接收数据包的速度, 缓存中的多个数据包会被应用程序当成一个包一次读取

解决: 

- 发送方使用 TCP_NODELAY 选项来关闭 Nagle 算法
- 数据包增加开始符和结束, 应用程序读取、区分数据包
- 在数据包的头部定义整个数据包的长度, 应用程序先读取数据包的长度, 然后读取整个长度的包字节数据, 保证读取的是单个包且完整

### get 和 post 请求有哪些区别;

在HTTP1.0中, 定义了三种请求方法GET, POST 和 HEAD方法

在HTTP1.1中, 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT方法 但我们常用的一般就是GET和POST请求

带敏感性的请求POST完全是应该的, 但普通请求(大多数获取数据请求)都应该往GET请求看齐

因为GET请求对于浏览器来说减轻了其压力、而且请求比POST快, 提升页面数据响应、渲染速度

区别具体如下

| 分类                                        | GET                                                          | POST                                                         | 对比                                                         |
| ------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 后退按钮/刷新                               | 无害                                                         | 数据会被重新提交(浏览器应该告知用户数据会被重新提交)         | 每次都重新提交这无疑会对浏览器造成压力, 该问题也是作为 web 端性能优化的重要方向之一 |
| 缓存                                        | 能被缓存                                                     | 不能缓存                                                     | 缓存可以为浏览器减少请求链数, web 端性能优化的重要方向之一   |
| 历史                                        | 参数保留在浏览器历史中                                       | 参数不会保存在浏览器历史中                                   | 相当于缓存, 可减少浏览器压力                                 |
| 对数据长度的限制                            | 当发送数据时, GET 方法向 URL 添加数据；URL 的长度是受限制的(URL 的最大长度是 2048 个字符) | 无限制                                                       | HTTP 协议没有 Body 和 URL 的长度限制, 对 URL 限制的大多是浏览器和服务器的原因；服务器是因为处理长 URL 要消耗比较多的资源, 为了性能和安全(防止恶意构造长 URL 来攻击)考虑, 会给 URL 长度加限制 |
| 安全性                                      | 与 POST 相比, GET 的安全性较差, 因为所发送的数据是 URL 的一部分; 在发送密码或其他敏感信息时绝不要使用 GET | POST 比 GET 更安全, 因为参数不会被保存在浏览器历史或 web 服务器日志中 | 从传输的角度来说, 他们都是不安全的, 因为 HTTP 在网络上是明文传输的, 浏览器F12下什么都一目了然, 或者抓个包, 就能完整地获取数据报文 ；要想安全传输, Encode(转码)当然对于懂的人来说也不安全； 比较安全的只有加密, 也就是 HTTPS |
| 对数据类型的限制                            | 只允许 ASCII 字符                                            | 没有限制; 也允许二进制数据                                   | POST 选择更多                                                |
| url编码( application/x-www-form-urlencoded) | 支持                                                         | 支持多种编码方式                                             |                                                              |

post 请求包含更多的请求头, 因为需要在请求的post部分包含数据, 所以会多了几个数据描述部分的首部字段(如content-type), 这其实是微乎其微的

post在真正接受数据之前会先将请求头发送给服务器进行确认, 然后才真正发送数据

get会将数据缓存起来, 而post不会

post不能进行管道化传输

GET和POST在本质上没有区别, 都是HTTP协议中的两种发送请求的方法。而HTTP呢，是基于TCP/IP的关于数据如何在万维网中如何通信的协议

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接

GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的

有人说POST 比 GET 安全，因为数据在地址栏上不可见。

然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。

其实，要想安全传输，就只有加密，也就是 HTTPS

Get、Post请求发送的数据包有什么不同吗?

GET请求时产生一个TCP数据包；POST请求时产生两个TCP数据包

- GET：浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
- POST：浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK（返回数据）

Get、POST性能差可以人为忽略

### HTTP协议的header是什么结构

### TCP 和 UDP 的区别

### TCP如何实现拥塞控制的

### TCP 怎么保证可靠传输

### 第三次握手存在的必要性是什么

### 如果TCP断了 client怎么处理

### 单链表和双链表的区别以及应用场景

### HTTP和 HTTPS的区别

### HTTPS的加密过程

### HTTPS 流程

### 公钥和私钥是怎么确立的, 加密用公钥还是秘钥, 解密呢？为什么

### HTTPS加密算法用在哪个步骤

### 滑动窗口

### TCP 如何保证不会接受重复的报文

### TCP 如何保证有序

### 客户端发送的第一个 syn 包丢包会发生什么

### TCP 滑动窗口是干嘛的(流量控制的一种方式), 说一下原理, 概念, 为什么叫滑动窗口

TCP中滑动窗口解决了可靠性以及传输速率问题

TCP协议中, 数据的发送方和接收方都会使用滑动窗口来控制数据的收发 有以下优点

- 避免等待
- 流量控制
- 效率高

滑动窗口的使用避免了数据重复校验, 在字符串匹配等场合有多应用

一个窗口由两个标志位决定

- 左指针指向窗口的左边界
- 右指针指向窗口的右边界

在移动时, 按以下流程

- 固定左边界
- 右边界移动
- 当满足条件时, 移动左边界

###  HTTP状态码有哪些

- 1XX: 信息状态码
- 2xx: 成功状态码
- 3xx: 重定向状态码
- 4xx: 客户端错误状态码
- 5xx: 服务端错误状态码

301 Moved Permanently: 永久性重定向

302 Found: 临时性重定向

303 See Other: 和302有着相同的功能, 但是303明确要求客户端应该采用GET方法获取资源

304 Not Modified: 如果请求报文首部包含一些条件, 例如:If-Match, If-Modified-Since, If-None- Match, If-Range, If-Unmodified-Since, 如果不满足条件, 则服务器会返回 304 状态码

307 Temporary Redirect: 临时重定向, 与302的含义类似, 但是307要求浏览器不会把重定向请求的POST方法改成GET方法

400 Bad Request: 请求报文中存在语法错误

401 Unauthorized: 该状态码表示发送的请求需要有认证信息

403 Forbidden: 请求被拒绝

404 Not Found

500 Internal Server Error: 服务器正在执行请求时发生错误

503 Service Unavailable: 服务器暂时处于超负载或正在进行停机维护, 现在无法处理请求

###  输入一个url用到了哪些协议

### HTTP协议由哪几部分组成

### HTTPS是是如何保证安全传输的

### 介绍 TCP HTTP和 HTTPS非对称和对称加密; 为什么对称用的多

### 五层网络协议 七层网络协议

### 丢包发生在哪一层 为什么

### 如果电脑联网失败 是哪一层有问题 为什么

### 怎么发生丢包问题 ping命令 这个命令用到了哪些协议 ICMP协议 这个协议具体是怎么使用的

### 开机时操作系统的整个运转过程是怎样的

### 解释HTTP协议; post和get的区别

### TCP和UDP的区别

### IP协议在哪一层; IP协议的作用

### Ping用的什么协议; 主机是如何区分收到的ICMP包的

### Ping的过程以及原理

### HTTP/1.0和HTTP/1.1的区别是什么; 那你了解HTTP/2么

- 长连接

- 缓存处理

- 带宽优化及网络连接的使用

### 在浏览器中输入URL后发生了什么

### 说一下TCP连接的过程

### HTTP通过什么保证安全传输

### 说一下应用层中使用UDP协议的应用？TCP？UDP+TCP

### TCP和 UDP 分别适用于什么场景

### HTTPS解析过程

### 用户如何找到DNS服务器

### DNS服务器是怎么知道IP地址的; 如何知道去哪里找DNS服务器

## Linux

### 查找一个日志中含有"123"的有多少个

### 查看特定时间的日志

### 常用的linux命令有哪些

 awk tr sort uniq命令

### 一段字符串 统计所有单词出现的次数

## JVM

### CMS和G1详细介绍一下

### 讲一讲CMS的回收过程

### 什么是字节码以及它的组成

Java 字节码 是 Java 虚拟机执行的一种指令格式

.class 文件是由十六进制值组成的, JVM以两个十六进制值为一组, 就是以字节为单位进行读取

- 魔数

- 版本号

- 常量池

  >常量池有两类常量: 字面量和符号引用
  >
  >常量池整体分为两个部分: 常量池计数器和常量池数据区

- 访问标志

- 当前类索引

- 父类索引

- 接口索引

- 字段表

- 方法表

- 附件属性

### 使用堆外内存的原因

- 对垃圾回收停顿的改善, 由于堆外内存是直接受操作系统管理而不是JVM, 所以使用堆外内存时可以保持较小的堆内内存规模, 从而在GC时减少回收停顿对应用的影响
- 提升程序I/O操作的性能, 通常在I/O通信过程中, 会存在堆内内存到堆外内存的数据拷贝动作, 对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据, 都建议储存到堆外内存

JDK8中使用元空间代替永久代的原因: 因为方法区所储存的类信息通常是比较难确定的, 所以对于方法区的大小是比较难指定的, 太小了容易出现方法区溢出, 太大了又会占用太多的虚拟机的内存空间, 干脆将方法区使用堆外内存实现

### 双亲委派模型的优势

### 内存泄露怎么排查

### jvm类加载过程

### 对象头的结构

### 什么情况下会触发 full GC

### JVM 为什么要指令重排

### 什么是TLAB？作用

### 垃圾回收主要回收哪些区域

### 对象什么情况会进去老年代

### 如何判断一个对象是否可回收

### 可达性分析后发现一个对象不在引用链上, 那它一定会被回收吗

### G1回收器采用了什么样的回收算法

### JVM 为什么要指令重排

### 什么区域 什么情况下会发生 OOM

### 什么时候会触发Full GC

### 如何打破双亲委派机制

### 符号引用是什么; 直接引用是什么

### 新生代一般用什么垃圾回收算法;为什么不用标记整理

### 详细说一下标记-清除, 复制和标记-整理算法

### 常用的JVM启动参数有哪些

```properties
# 设置堆内存
-Xmx4g -Xms4g
# 指定GC算法
-XX:+UseG1Gc -XX:MaxGCPauseMillis=50
# 指定GC并行线程数
-XX:ParallelGCThreads=4
# 打印GC日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps
# 指定GC日志文件
-Xloggc:gc.log
# 指定Meta区的最大值
-XX:MaxMetaspaceSize=2g
# 设置单个线程栈的大小
-Xss1m
# 指定堆内存溢出时自动进行dump
-XX+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/usr/local
```

### java8默认使用的垃圾回收器是什么

并行垃圾收集器(Parallel GC)

### 安全点

用户线程暂停 GC线程要开始工作 但是要确保用户线程暂停的这行字节码指令是不会导致引用关系的变化 所以JVM会在字节码指令中 选一些指令作为安全点 比如方法的调用 循环跳转 异常跳转等

主动式中断是设置一个标志 这个标志是中断标志 各业务线程在运行过程中会不停地主动去轮询这个标志 一旦发现中断标志为True 就会在自己最近的安全点上主动中断挂起

安全区域

如果业务线程不在执行状态(Sleep或者Blocked) 那么程序就无法进入安全点 对于这种情况就必须进入安全区域

安全区域可以看作被扩展拉伸了的安全点

当用户线程执行到安全区域里面的代码时 首先会标记自己已经进入到安全区域 这段时间里JVM要发起GC则不必去管这个线程 当线程要离开安全区域时 要判断JVM是否完成了垃圾回收

- 如果完成了 那线程则继续执行
- 否则一直等待 直到收到可以离开安全区域的信号为止

### CMS G1垃圾回收器中的三色标记

三色标记是一种垃圾回收法 它可以让JVM不发生或者仅短时间发生STW 从而达到清除JVM内存垃圾的目的

- 黑色 该对象已经被标记过了且该对象下的属性也全部都被标记过了
- 白色 对象已经被垃圾收集器扫描过了 但是对象中还存在没有扫描的引用
- 灰色 表示对象没有被垃圾回收器访问过 即表示不可达

三色标记的漏标问题

CMS的解决方案 Incremental Update(重新扫描)

G1的解决方案 SATB(snapshot-at-the-beginning)

## 框架

### Spring 自动装配 bean 有哪些方式

### Spring 实现事务方式有哪些

### 说一些 Spring MVC 的运行流程

### Spring MVC 有哪些组件

### Spring Boot 和 Spring 的区别

### Spring Boot 的启动流程

### ES 写入数据和查询数据的工作原理是什么

### 底层的 Lucene 介绍一下

### 倒排索引的原理说一下 ES 在数据量很大的情况下, 比如数十亿级别, 如何提高查询效率啊

### ES 生产集群的部署架构是什么

### Nacos集群CP架构底层类Raft协议怎么实现的

### Sentinel底层是如何计算线上系统实时QPS的

### 不使用redis 存储session该怎么做

### 缓存的雪崩里面加上的随机值如何选取

### 讲一下负载均衡

### 注解底层怎么实现的

### 注解失效有哪些原因

### cookie 和 session; session存储在服务端哪里

- 存储位置不同 cookie的数据信息存放在客户端浏览器上; session的数据信息存放在服务器上
- 存储容量不同 单个cookie保存的数据<=4KB, 一个站点最多保存20个Cookie; 对于session来说并没有上限, 但出于对服务器端的性能考虑, session内不要存放过多的东西, 并且设置session删除机制
- 存储方式不同 cookie中只能保管ASCII字符串, 并需要通过编码方式存储为Unicode字符或者二进制数据; session中能够存储任何类型的数据
- 隐私策略不同 cookie对客户端是可见的, 别有用心的人可以分析存放在本地的cookie并进行cookie欺骗, 所以它是不安全的; session存储在服务器上, 对客户端是透明对, 不存在敏感信息泄漏的风险
- 有效期上不同 开发可以通过设置cookie的属性, 达到使cookie长期有效的效果; session依赖于名为JSESSIONID的cookie, 而cookie JSESSIONID的过期时间默认为-1, 只需关闭窗口该session就会失效, 因而session不能达到长期有效的效果
- 服务器压力不同 cookie保管在客户端, 不占用服务器资源; session是保管在服务器端的, 每个用户都会产生一个session
- 浏览器支持不同 cookie是需要客户端浏览器支持的, 假如客户端禁用了cookie, 或者不支持cookie, 则会话跟踪会失效, 关于WAP上的应用, 常规的cookie就派不上用场了; 运用session需要使用URL地址重写的方式, 一切用到session程序的URL都要进行URL地址重写, 否则session会话跟踪还会失效
- 跨域支持上不同 cookie支持跨域名访问; session不支持跨域名访问

### 说一下NGINX的反向代理和正向代理

### nginx(反向代理、负载均衡)

### rpc了解过没有

### 处理2.5亿的数据, 怎么样找出不重复的数据

(使用2bitmap, 00表示不存在, 01表示唯一, 10表示重复)

## 设计模式

### 设计模式有哪些大类

创建型

- 工厂模式(Factory Pattern)
- 抽象工厂模式(Abstract Factory Pattern)
- 单例模式(Singleton Pattern)
- 建造者模式(Builder Pattern)
- 原型模式(Prototype Pattern)

结构型

- 适配器模式(Adapter Pattern)
- 桥接模式(Bridge Pattern)
- 过滤器模式(Filter、Criteria Pattern)
- 组合模式(Composite Pattern)
- 装饰器模式(Decorator Pattern)
- 外观模式(Facade Pattern)
- 享元模式(Flyweight Pattern)
- 代理模式(Proxy Pattern)

行为型

- 责任链模式(Chain of Responsibility Pattern)
- 命令模式(Command Pattern)
- 解释器模式(Interpreter Pattern)
- 迭代器模式(Iterator Pattern)
- 中介者模式(Mediator Pattern)
- 备忘录模式(Memento Pattern)
- 观察者模式(Observer Pattern)
- 状态模式(State Pattern)
- 空对象模式(Null Object Pattern)
- 策略模式(Strategy Pattern)
- 模板模式(Template Pattern)
- 访问者模式(Visitor Pattern)

### 设计模式的六大原则

开闭原则

里氏替换原则

依赖倒转原则

接口隔离原则

迪米特法则

合成复用原则

### 简单讲讲策略模式, 观察者模式有了解吗

### 工厂模式, 简单工厂和抽象工厂的区别

### 简单工厂存在的问题

## 算法

两个栈实现队列

打印二叉树的左边界

二叉树转双向链表

k个反转链表

最长重复子串

接雨水

(滑动窗口)求数组中连续k个数的最大平均值 

二叉树的序列化和反序列化

加油站问题

链表元素的交换

lc(227)计算器

[leetcode](https://www.nowcoder.com/jump/super-jump/word?word=leetcode)[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

求一颗二叉树的平均高度

旋转数组二分

连续子数组最大和

两个链表相加

k个一组反转链表

判断A是否是B的子树

最长回文子串

链表重新排序

最大无重复子串长度

螺旋二维数组

下一个排列

括号匹配

LRU缓存数据结构

有序数组生成平衡二叉树

 二叉树中的最大路径和

顺时针打印矩阵

二叉树的公共祖先, 要求递归直接返回结果, 不使用全局变量