

并发编程最早的应用领域就是操作系统的实现

并发编程的第一原则，那就是不要写并发程序

synchronized、wait()、notify() 不过是操作系统领域里管程模型的一种实现而已，Java SDK 并发包里的条件变量 Condition 也是管程里的概念

管程作为一种解决并发问题的模型，是继信号量模型之后的一项重大创新，它与信号量在逻辑上是等价的（可以用管程实现信号量，也可以用信号量实现管程），但是相比之下管程更易用 而且，很多编程语言都支持管程

其实并发编程可以总结为三个核心问题：分工、同步、互斥。所谓分工指的是如何高效地拆解任务并分配给线程，而同步指的是线程之间如何协作，互斥则是保证同一时刻只允许一个线程访问共享资源。Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段

Java SDK 并发包，它不过是针对并发问题开发出来的工具而已 其余的一部分则是并发容器和原子类，这些比较容易理解，属于辅助工具，其他语言里基本都能找到对应的

并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了，当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多

### 管程（Monitor）模型详解

管程（Monitor）是一种进程/线程同步机制，由 **Dijkstra**、**Hoare**（C.A.R.Hoare） 和 **Brinch Hansen** （Per Brinch Hansen） 等人在 20 世纪 70 年代提出，用于解决多线程环境下的**互斥访问共享资源**和**线程间通信**问题。

管程是一个高级同步原语

- 共享变量
- 操作共享变量的过程
- 同步机制

#### 管程的组成

- 互斥锁（Mutex Lock）
- 条件变量（Condition Variables）
- 入口队列（Entry Queue）
- 条件变量等待队列

#### 管程的两种实现风格

- Hoare 管程（`signal()` 立即切换线程，唤醒者（调用 `signal()` 的线程）挂起，被唤醒线程立即执行），保证被唤醒线程能立即看到条件成立，但上下文切换开销较大
- Mesa 管程（`signal()` 仅通知，不立即切换，被唤醒线程重新竞争锁，可能发现条件再次不成立（需用 `while` 检查））

其中Java 的 `synchronized` 和 `wait()`/`notify()`实现了 Mesa 风格的管程
