并发编程领域可以抽象成三个核心问题：分工、同步和互斥

Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题

Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的

在 Java 并发编程领域，解决协作问题的核心技术是管程，上面的所有线程协作技术底层都是利用管程解决的。

管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决互斥问题。可以这么说，管程是解决并发问题的万能钥匙。

分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫“线程安全”

并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题，为了解决这三个问题，Java 语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥

所谓互斥，指的是同一时刻，只允许一个线程访问共享变量

实现互斥的核心技术就是锁

如何保证安全性的同时又尽量提高性能:

Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式

使用锁除了要注意性能问题外，还需要注意死锁问题

技术的本质是背后的理论模型
