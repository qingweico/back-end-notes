[TOC]

由于自增主键可以让主键索引尽量地保持递增顺序插入,避免了页分裂,因此索引更紧凑, 但是自增主键不能保证连续递增

演示表结构

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `c` (`c`)
) ENGINE=InnoDB;
```

### 自增值保存在哪儿

通过语句直观看到

- 先执行`insert into t values(null, 1, 1);` 插入一条数据
- `show create table t` 查看目前的建表语句
- 发现表定义里面出现了一个 AUTO_INCREMENT=2

先说结论

- 表的结构定义存放在后缀名为.frm 的文件中,但是并不会保存自增值

不同的引擎对于自增值的保存策略不同

- MyISAM 引擎的自增值保存在数据文件中
- InnoDB 引擎的自增值,其实是保存在了内存里,并且到了 MySQL 8.0 版本后,才有了"自增值持久化"的能力,也就是才实现了"如果发生重启,表的自增值可以恢复为 MySQL 重启前的值"
  - 在 MySQL 5.7 及之前的版本,自增值保存在内存里,并没有持久化; 每次重启后,第一次打开表的时候,都会去找自增值的最大值 max(id),然后将 max(id)+1 作为这个表当前的自增值,但是如果重启前,删除当前id最大的那条记录,再重启后,AUTO_INCREMENT就会变化,换句话说,MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值
  - 在 MySQL 8.0 版本,将自增值的变更记录在了 redo log 中,重启的时候依靠 redo log 恢复重启之前的值

### 自增值修改机制

- 如果插入数据时 id 字段指定为 0、null 或未指定值,那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段
- 如果插入数据时 id 字段指定了具体的值,就直接使用语句里指定的值
- 如果当前插入的值小于表的自增值(AUTO_INCREMENT),那么这个表的自增值不变
- 如果当前插入的值大于等于表的自增值,就需要把当前自增值修改为新的自增值

新的自增值生成算法是:从 auto_increment_offset 开始,以 auto_increment_increment 为步长,持续叠加,直到找到第一个大于 【当前插入】的值,作为新的自增值,其中,auto_increment_offset 和 auto_increment_increment 是两个系统参数,分别用来表示自增的初始值和步长,默认值都是 1

备注

- 在一些场景下,使用的就不全是默认值; 比如,双 M 的主备结构里要求双写的时候,我们就可能会设置成 auto_increment_increment=2,让一个库的自增 id 都是奇数,另一个库的自增 id 都是偶数,避免两个库生成的主键发生冲突

### 自增值的修改时机

- 唯一键冲突是导致自增主键 id 不连续的第一种原因
- 事务回滚也会产生类似的现象,这就是第二种原因

原因就是在出现唯一键冲突或者回滚的时候,MySQL 没有把表的自增值改回去,这么设计是有原因的:提升性能

- 两个并行执行的事务都要申请主键,但是一个成功了,一个失败了,如果失败的那个事务回退了表的自增值,那么其他事务就会申请到表中已存在的主键值,就会报主键冲突错误

解决这种冲突有两种办法

- 每次申请id前都要去表里判断下该id是否存在
- 把自增 id 的锁范围扩大,必须等到一个事务执行完成并提交,下一个事务才能再申请自增 id,这个方法的问题,就是锁的粒度太大,系统并发能力大大下降

所以这两种方法都会存在性能问题,因此,InnoDB 放弃了这个设计,语句执行失败也不回退自增 id,所以才只保证了自增 id 是递增的,但不保证是连续的

### 自增锁的优化

自增 id 锁并不是一个事务锁,而是每次申请完就马上释放,以便允许别的事务再申请

### 自增锁设计的历史

- 在 MySQL 5.0 版本的时候,自增锁的范围是语句级别; 也就是说,如果一个语句申请了一个表自增锁,这个锁会等语句执行结束以后才释放; 显然,这样设计会影响并发度
- MySQL 5.1.22 版本引入了一个新策略,新增参数 innodb_autoinc_lock_mode,默认值是 1
  - 这个参数的值被设置为 0 时,表示采用之前 MySQL 5.0 版本的策略,即语句执行结束后才释放锁
  - 这个参数的值被设置为 1 时,普通 insert 语句,自增锁在申请之后就马上释放,类似 insert … select 这样的批量插入数据的语句,自增锁还是要等语句结束后才被释放(为了数据的一致性)
  - 这个参数的值被设置为 2 时,所有的申请自增主键的动作都是申请后就释放锁

详细说下为什么类似 insert … select 这样的批量插入数据的语句,自增锁还是要等语句结束后才被释放

- 主要原因就是在主从复制的时候,当binlog_format=statement时,如果插入数据时同时(申请了自增值以后马上就释放自增锁),别的会话也会插入数据,此时插入的主键就会不连续,但是生成的binlog日志拿到备库串行执行时,生成的id是连续的,此时就发生了数据不一致

所以为了解决这个问题,有两种方法

- 让原库的批量插入数据语句,固定生成连续的 id 值(通过自增锁直到语句执行结束才释放可以保证)
- 在 binlog 里面把插入数据的操作都如实记录进来,到备库执行的时候,不再依赖于自增主键去生成(通过binlog_format 设置为 row保证)

上述两种方法就其实就是  innodb_autoinc_lock_mode 设置为 2,同时 binlog_format 设置为 row(既能提升并发性,又不会出现数据一致性问题)

批量插入数据,包含的语句类型是 insert … select、replace … select 和 load data 语句

- insert … select (不知道源表会返回多少行)
- replace … select (不知道哪些行会冲突并被替换)
- load data (文件导入,无法预知行数)

上述这种语句的问题就是无法预先知道最终需要多少个自增id,所以会设置【自增锁等语句结束后才被释放】

说下 innodb_autoinc_lock_mode 设置为1时,为什么普通的 insert 语句里面包含多个 value 值的情况下,也不会等语句执行完成才释放锁

- 因为这类语句在申请自增 id 的时候,是可以精确计算出需要多少个 id 的,然后一次性申请,申请完成后锁就可以释放了

如果一个 select … insert 语句要插入 10 万行数据,为了避免申请 10 万次id,所以MySQL 有一个批量申请自增 id 的策略

- 语句执行过程中,第一次申请自增 id,会分配 1 个
- 1 个用完以后,这个语句第二次申请自增 id,会分配 2 个
- 2 个用完以后,还是这个语句,第三次申请自增 id,会分配 4 个
- 依此类推,同一个语句去申请自增 id,每次申请到的自增 id 个数都是上一次的两倍

所以如果实际插入的数据少于MySQL批量申请id的数量的话,后续的id就会浪费掉,后续再次插入就会从上次结束申请id的最大值开始,这是主键 id 出现自增 id 不连续的第三种原因

### 小结

在 MyISAM 引擎里面,自增值是被写在数据文件上的; 而在 InnoDB 中,自增值是被记录在内存的; MySQL 直到 8.0 版本,才给 InnoDB 表的自增值加上了持久化的能力,确保重启前后一个表的自增值不变

MySQL 5.1.22 版本开始引入的参数 innodb_autoinc_lock_mode,控制了自增值申请时的锁范围; 从并发性能的角度考虑,建议将其设置为 2,同时将 binlog_format 设置为 row

