[TOC]

## mysql中的各种自增id

### 自增主键

- 表的自增 id 达到上限后,再申请时它的值就不会改变,进而导致继续插入数据时报主键冲突的错误

### row_id

- 如果你创建的 InnoDB 表没有指定主键,那么 InnoDB 会给你创建一个不可见的,长度为 6 个字节的 row_id

- row_id 达到上限后,则会归 0 再重新递增,如果出现相同的 row_id,后写的数据会覆盖之前的数据
- 可以使用 _rowid 查询
- _rowid 是伪列,不是物理存储的列,而是运行时计算的值,其显示规则为有单列主键显示主键值,有单列唯一非空索引则显示该索引的值,如果无主键,显示隐藏的 row_id,其值来自来自 `dict_sys.row_id`

### Xid

- MySQL 内部维护了一个全局变量 global_query_id,每次执行语句的时候将它赋值给 Query_id,然后给这个变量加 1,如果当前语句是这个事务执行的第一条语句,那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid

- Xid 只需要不在同一个 binlog 文件中出现重复值即可; 虽然理论上会出现重复值,但是概率极小,可以忽略不计
- 虽然 MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid,但是如果 global_query_id 达到上限后,就会继续从 0 开始计数; 从理论上讲,还是就会出现同一个 binlog 里面出现相同 Xid 的场景

### trx_id

- Xid 是由 server 层维护的; InnoDB 内部使用 Xid,就是为了能够在 InnoDB 事务和 server 之间做关联; 但是,InnoDB 自己的 trx_id,是另外维护的,trx_id就是MVCC的版本号,是InnoDB内部自己维护的,每次事务开启时都会向InnoDB事务系统申请,是严格顺序递增的
- InnoDB 内部维护了一个 max_trx_id 全局变量,每次需要申请一个新的 trx_id 时,就获得 max_trx_id 的当前值,然后并将 max_trx_id 加 1

- InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来,重启也不会重置为 0,从理论上讲,只要一个 MySQL 服务跑得足够久,就可能出现 max_trx_id 达到 248-1 的上限,然后从 0 开始的情况
- 对于只读事务,InnoDB 并不会分配 trx_id
- update 和 delete 语句除了事务本身,还涉及到标记删除旧数据,也就是要把数据放到 purge 队列里等待后续物理删除,这个操作也会把 max_trx_id+1, 因此在一个事务中至少加 2
- InnoDB 的后台操作,比如表的索引信息统计这类操作,也是会启动内部事务的

只读事务不分配 trx_id 的原因

- 减小事务视图里面活跃事务数组的大小
- 减少 trx_id 的申请次数(一个普通的 select 语句,在执行过程中,也是要对应一个只读事务的,所以普通的查询语句不需要申请 trx_id,就大大减少了并发事务申请 trx_id 的锁冲突)
- 只读事务的trx_id 显示的会比较大

### thread_id

- thread_id 是我们使用中最常见的,而且也是处理得最好的一个自增 id

### 补充

实际上,在代码实现时 row_id 和 trx_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned); 但是,实际在内存中是64位,磁盘存储时截断为48位