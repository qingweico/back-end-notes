### 全局锁

MySQL 提供了一个加全局读锁的方法, 命令是 Flush tables with read lock (FTWRL)

全局锁的典型使用场景是, 做全库逻辑备份, 也就是把整库每个表都 select 出来存成文本

### 表级锁

MySQL 里面表级别的锁有两种: 一种是表锁, 一种是元数据锁(meta data lock, MDL)

表锁的语法是 lock tables t read/write

在 MySQL 5.5 版本中引入了 MDL, 当对一个表做增删改查操作的时候, 加 MDL 读锁；当要对表做结构变更操作的时候, 加 MDL 写锁

事务中的 MDL 锁, 在语句执行开始时申请, 但是语句结束后并不会马上释放, 而会等到整个事务提交后再释放

首先我们要解决长事务, 事务不提交, 就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中, 你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行, 要考虑先暂停 DDL, 或者 kill 掉这个长事务

比较理想的机制是, 在 alter table 语句里面设定等待时间, 如果在这个指定的等待时间里面能够拿到 MDL 写锁最好, 拿不到也不要阻塞后面的业务语句, 先放弃

### 行锁

在 InnoDB 事务中, 行锁是在需要的时候才加上的, 但并不是不需要了就立刻释放, 而是要等到事务结束时才释放, 这个就是两阶段锁协议

### 死锁

死锁以后, 有两种策略:

一种策略是, 直接进入等待, 直到超时; 这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置; 另一种策略是, 发起死锁检测, 发现死锁后, 主动回滚死锁链条中的某一个事务, 让其他事务得以继续执行; 将参数 innodb_deadlock_detect 设置为 on, 表示开启这个逻辑

在 InnoDB 中, innodb_lock_wait_timeout 的默认值是 50s

### 事务

begin/start transaction 命令并不是一个事务的起点, 在执行到它们之后的第一个操作 InnoDB 表的语句, 事务才真正启动

如果你想要马上启动一个事务, 可以使用 start transaction with consistent snapshot 这个命令

第一种启动方式, 一致性视图是在执行第一个快照读语句时创建的

第二种启动方式, 一致性视图是在执行 start transaction with consistent snapshot 时创建的

在 MySQL 里, 有两个“视图”的概念

- 一个是 view; 它是一个用查询语句定义的虚拟表, 在调用的时候执行查询语句并生成结果; 创建视图的语法是 create view … , 而它的查询方法与表一样
- 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图, 即 consistent read view, 用于支持 RC(Read Committed, 读提交)和 RR(Repeatable Read, 可重复读)隔离级别的实现 它没有物理结构, 作用是事务执行期间用来定义“我能看到什么数据”

在可重复读隔离级别下, 事务在启动的时候就“拍了个快照”; 注意, 这个快照是基于整库的

InnoDB 里面每个事务有一个唯一的事务 ID, 叫作 transaction id; 它是在事务开始的时候向 InnoDB 的事务系统申请的, 是按申请顺序严格递增的

数据表中的一行记录, 其实可能有多个版本 (row), 每个版本有自己的 row trx_id

可重复读的定义, 一个事务启动的时候, 能够看到所有已经提交的事务结果。但是之后, 这个事务执行期间, 其他事务的更新对它不可见

在实现上,  InnoDB 为每个事务构造了一个数组, 用来保存这个事务启动瞬间, 当前正在“活跃”的所有事务 ID。“活跃”指的就是, 启动了但还没提交; 数组里面事务 ID 的最小值记为低水位, 当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位; 这个视图数组和高水位, 就组成了当前事务的一致性视图(read-view); 而数据版本的可见性规则, 就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的

更新数据都是先读后写的, 而这个读, 只能读当前的值, 称为“当前读”(current read)

除了 update 语句外, select 语句如果加锁, 也是当前读 lock in share mode 或 for update 读锁(S 锁, 共享锁)和写锁(X 锁, 排他锁)

可重复读的核心就是一致性读(consistent read)；而事务更新数据的时候, 只能用当前读; 如果当前的记录的行锁被其他事务占用的话, 就需要进入锁等待

读提交的逻辑和可重复读的逻辑类似, 它们最主要的区别是: 

- 在可重复读隔离级别下, 只需要在事务开始的时候创建一致性视图, 之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下, 每一个语句执行前都会重新算出一个新的视图

“start transaction with consistent snapshot; ”的意思是从这个语句开始, 创建一个持续整个事务的一致性快照。所以, 在读提交隔离级别下, 这个用法就没意义了, 等效于普通的 start transaction

每个事务或者语句有自己的一致性视图; 普通查询语句是一致性读, 一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性

对于可重复读, 查询只承认在事务启动前就已经提交完成的数据；

对于读提交, 查询只承认在语句启动前就已经提交完成的数据；

而当前读, 总是读取已经提交完成的最新版本