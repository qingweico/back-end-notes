![img](https://static-i0.oss-cn-shanghai.aliyuncs.com/pic/0d2070e8f84c4801adbfa03bda1f98d9.png)

MySQL 可以分为 Server 层和存储引擎层两部分

Server 层包括连接器、查询缓存、分析器、优化器、执行器等, 涵盖 MySQL 的大多数核心服务功能, 以及所有的内置函数(如日期、时间、数学和加密函数等), 所有跨存储引擎的功能都在这一层实现, 比如存储过程、触发器、视图等

InnoDB, 从 MySQL 5.5.5 版本开始成为了默认存储引擎

在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表; 不同存储引擎的表数据存取方式不同, 支持的功能也不同

### 连接器

接器负责跟客户端建立连接、获取权限、维持和管理连接

```shell
mysql -h$ip -P$port -u$user -p
```

连接命令中的 mysql 是客户端工具, 用来跟服务端建立连接; 在完成经典的 TCP 握手后, 连接器就要开始认证你的身份, 这个时候用的就是你输入的用户名和密码

- 如果用户名或密码不对, 你就会收到一个"Access denied for user"的错误, 然后客户端程序结束执行; 
- 如果用户名密码认证通过, 连接器会到权限表里面查出你拥有的权限; 之后, 这个连接里面的权限判断逻辑, 都将依赖于此时读到的权限

一个用户成功建立连接后, 即使你用管理员账号对这个用户的权限做了修改, 也不会影响已经存在连接的权限; 修改完成后, 只有再新建的连接才会使用新的权限设置

连接完成后, 如果你没有后续的动作, 这个连接就处于空闲状态, 你可以在` show processlist `命令中看到它

客户端如果太长时间没动静, 连接器就会自动将它断开; 这个时间是由参数` wait_timeout` 控制的, 默认值是 8 小时

数据库里面, 长连接是指连接成功后, 如果客户端持续有请求, 则一直使用同一个连接; 短连接则是指每次执行完很少的几次查询就断开连接, 下次查询再重新建立一个

建立连接的过程通常是比较复杂的, 所以我建议你在使用中要尽量减少建立连接的动作, 也就是尽量使用长连接

全部使用长连接后, 你可能会发现, 有些时候 MySQL 占用内存涨得特别快, 这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的; 这些资源会在连接断开的时候才释放

- 定期断开长连接; 使用一段时间, 或者程序里面判断执行过一个占用内存的大查询后, 断开连接, 之后要查询再重连
- 果你用的是 MySQL 5.7 或更新版本, 可以在每次执行一个比较大的操作后, 通过执行 mysql_reset_connection 来重新初始化连接资源; 这个过程不需要重连和重新做权限验证, 但是会将连接恢复到刚刚创建完时的状态

### 查询缓存

查询缓存的失效非常频繁, 只要有对一个表的更新, 这个表上所有的查询缓存都会被清空

除非你的业务就是有一张静态表, 很长时间才会更新一次; 比如, 一个系统配置表, 那这张表上的查询才适合使用查询缓存

MySQL 8.0 版本直接将查询缓存的整块功能删掉了, 也就是说 8.0 开始彻底没有这个功能了

### 分析器

分析器先会做“词法分析”, 你输入的是由多个字符串和空格组成的一条 SQL 语句, MySQL 需要识别出里面的字符串分别是什么, 代表什么 

“语法分析”; 根据词法分析的结果, 语法分析器会根据语法规则, 判断你输入的这个 SQL 语句是否满足 MySQL 语法

### 优化器

优化器是在表里面有多个索引的时候, 决定使用哪个索引；或者在一个语句有多表关联(join)的时候, 决定各个表的连接顺序

优化器阶段完成后, 这个语句的执行方案就确定下来了, 然后进入执行器阶段

### 执行器

开始执行的时候, 要先判断一下你对这个表 T 有没有执行查询的权限, 如果没有, 就会返回没有权限的错误

权限验证不仅仅在执行器这部分会做, 在分析器之后, 也就是知道了该语句要“干什么”之后, 也会先做一次权限验证; 叫做precheck; 而precheck是无法对运行时涉及到的表进行权限验证的, 比如使用了触发器的情况; 因此在执行器这里也要做一次执行时的权限验证

如果有权限, 就打开表继续执行; 打开表的时候, 执行器就会根据表的引擎定义, 去使用这个引擎提供的接口

数据库的慢查询日志中看到一个 rows_examined 的字段, 表示这个语句执行过程中扫描了多少行; 这个值就是在执行器每次调用引擎获取数据行的时候累加的

执行器调用一次, 在引擎内部则扫描了多行, 因此引擎扫描行数跟 rows_examined 并不是完全相同的