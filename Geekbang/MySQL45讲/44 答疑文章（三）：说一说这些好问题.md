[TOC]

## join 的写法

示例建表语句

```mysql
create table a(f1 int, f2 int, index(f1))engine=innodb;
create table b(f1 int, f2 int)engine=innodb;
insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
```

下面两种不同join的写法(区别就是条件是放在on中还是放在where中)
```mysql
select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/
select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/
```

说明

- Q1 中on条件是 join的一部分,决定了是否能够匹配到右表,不会影响到左表的行数,保留了 left join 的语义
-  Q1 中 a 是驱动表, b 是被驱动表,其字段f1 没有索引,使用了 BNL 算法
- Q2 中 条件是在 JOIN 结果之后做过滤,会过滤掉右表为 NULL 的行,条件写在 WHERE 里,会让left join 退化成 inner join ,从而破坏 LEFT JOIN的语义
- Q2中 b 是驱动表,使用的是NLJ 算法

小技巧:在join语句中怎么查看谁是驱动表

- 在 explain 中谁先被访问(先扫描、先取行),谁就是驱动表,即table 的出现顺序就是实际执行顺序

关于上面两种语句执行的差异: 优化器基于 Q2 这个查询的语义做了优化

- 基于下面的 NULL 等值比较的原因, 优化器把语句的 left join 改写成了 join
- 因为表 a 的 f1 上有索引,就把表 b 作为驱动表,这样就可以用上 NLJ 算法

先说个 MySQL 中关于 NULL的知识点: 在 MySQL 里,NULL 跟任何值执行等值判断和不等值判断的结果,都是 NULL

- select NULL = NULL 结果还是 NULL
- 首先 NULL 不是一个 值,而是表示未知,未知和未知做比较,结果就是未知,就像无穷大和无穷小
- 判断 NULL 使用 IS NULL / IS NOT NULL, 而不是等值或者不等值判断,即使用状态判断而不是等值判断
- 通过提供上述方式判断 NULL(不基于比较的 NULL 判断方式),避免了数据库无法判断 NULL 行的问题

结论

- 使用 left join 时,左边的表不一定是驱动表
- 如果需要 left join 的语义,就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断,必须都写在 on 里面

使用 inner join 的示例

```mysql
select * from a join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q3*/
select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q4*/
```

都会被修改为如下的语句

```mysql
select * from a join b where (a.f1=b.f1) and (a.f2=b.f2);
```

## Simple Nested Loop Join 的性能问题

问题:BNL 算法和 Simple Nested Loop Join算法都会先将数据读到内存中,但是为什么会有性能差距

先说下两种算法的大致执行逻辑

BNL逻辑

- 将驱动表的数据全部读入内存 join_buffer 中,这里 join_buffer 是无序数组
- 然后,顺序遍历被驱动表的所有行,每一行数据都跟 join_buffer 中的数据进行匹配,匹配成功则作为结果集的一部分返回

SNLJ逻辑

- 顺序取出驱动表中的每一行数据,到被驱动表去做全表扫描匹配,匹配成功则作为结果集的一部分返回

原因(与MySQL 中索引结构和 Buffer Pool 相关)

- 在对被驱动表做全表扫描的时候,如果数据没有在 Buffer Pool 中,就需要等待这部分数据从磁盘读入,从磁盘读入数据到内存中,会影响正常业务的 Buffer Pool 命中率,而且这个算法天然会对被驱动表的数据做多次访问,更容易将这些数据页放到 Buffer Pool 的头部
-  即使被驱动表数据都在内存中,每次查找"下一个记录的操作",都是类似指针操作; 而 join_buffer 中是数组,遍历的成本更低

所以说,BNL 算法的性能会更好

虽然BNL 和 SNLJ 都会使用 join_buffer,从磁盘拿数据, 但是由于SNLJ会多次遍历,而BNL只会拿一次

## distinct 和 group by 的性能

问题:如果表 t 的字段 a 上没有索引, 下面这两条语句的执行性能是不是相同的

```mysql
select a from t group by a order by null;
select distinct a from t;
```

结论:不需要执行聚合函数时,distinct 和 group by 这两条语句的语义和执行流程是相同的,因此执行性能也相同

这两条语句的执行流程是下面这样的

- 创建一个临时表,临时表有一个字段 a,并且在这个字段 a 上创建一个唯一索引
- 遍历表 t,依次取数据插入临时表中:如果发现唯一键冲突,就跳过;否则插入成功
- 遍历完成后,将临时表作为结果集返回给客户端

说下group by 的写法

```mysql
-- 符合 SQL 标准的写法
select a,count(*) from t group by a order by null;
-- 标准 SQL 的 GROUP BY
SELECT 列表中的非聚合列必须出现在 GROUP BY 子句中
-- 反例,也可以执行,因为对每个 id,username是唯一的, 但是如果id换成别的列就不行了
SELECT id, username FROM t_user GROUP BY id;
```

- GROUP BY 不要求必须有聚合函数,如果没有聚合函数(纯分组),就是等价于 DISTINCT
- 一旦 SELECT 里出现非聚合列,这些列必须由 GROUP BY 唯一确定

## 备库自增主键问题

问题:因为获取自增id和写binlog是有先后顺序的,那么在binlog为statement的情况下(row 格式的 binlog 就没有这个问题),语句A先获取id=1,然后B获取id=2,接着B提交,写binlog,再A写binlog;  这个时候如果binlog重放,是不是会发生B的id为1,而A的id为2的不一致的情况

先说结论:不会

原因:在 insert 语句之前,还有一句 SET INSERT_ID=1(这个 SET INSERT_ID 语句是固定跟在 insert 语句之前的),作用就是这个线程里下一次需要用到自增值的时候,不论当前表的自增值是多少,固定用 1 这个值,因此,即使两个 INSERT 语句在主备库的执行顺序不同,自增主键字段的值也不会不一致