[TOC]

问题:如果备库执行日志的速度持续低于主库生成日志的速度,那这个延迟就有可能成了小时级别; 而且对于一个压力持续比较高的主库来说,备库很可能永远都追不上主库的节奏

日志在备库上的执行,会使用sql_thread 更新数据,如果是用单线程的话,就会导致备库应用日志不够快,造成主备延迟,在官方的 5.6 版本之前,MySQL 只支持单线程复制,由此在主库并发高、TPS 高时就会出现严重的主备延迟问题

### 多线程复制机制

将一个线程的 sql_thread拆分成多个线程

![多线程模型](https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png?wh=1142*856)

- coordinator 就是原来的 sql_thread, 不过现在它不再直接更新数据了,只负责读取中转日志和分发事务
- 真正更新日志的,变成了 worker 线程; 而 work 线程的个数,就是由参数 slave_parallel_workers 决定的

问题一:不同的事务可不可以分给不同的 worker 执行吗

不行,因为不同的 worker 是相互独立的,由于 CPU 的调度策略,可能会出现事务执行顺序相反的情况,如果这时候刚好这两个事务更新的是同一行,同一行上的两个事务,在主库和备库上的执行顺序相反,会导致主备不一致的问题

问题二:同一个事务的多个更新语句,能不能分给不同的 worker 来执行呢

不行,一个事务更新了表 t1 和表 t2 中的各一行,如果这两条更新语句被分到不同 worker 的话,虽然最终的结果是主备一致的,但如果表 t1 执行完成的瞬间,备库上有一个查询,就会看到这个事务"更新了一半的结果",破坏了事务逻辑的隔离性

coordinator 在分发的时候,需要满足以下这两个基本要求

- 不能造成更新覆盖; 这就要求更新同一行的两个事务,必须被分发到同一个 worker 中

- 同一个事务不能被拆开,必须放到同一个 worker 中