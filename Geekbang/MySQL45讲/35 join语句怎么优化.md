[TOC]

## Multi-Range Read 优化(mrr)

其主要目的是尽量使用顺序读盘

回表中可能出现的问题

- 先回忆下, 回表是指 InnoDB 在普通索引上查到主键的值后,再根据一个个主键的值到主键索引上去查整行数据的过程
- 但是如果二级索引的值不是和主键的值一样是递增的话,随着 二级索引的值递增顺序查询的话,id 的值就变成随机的,那么就会出现随机访问,性能相对较差
- 基于这个共识:如果按照主键的递增顺序查询的话,对磁盘的读比较接近顺序读,能够提升读性能,所以MRR 优化的设计思路出现了

优化流程

- 根据二级索引,定位到满足条件的记录,将 id 值放入 read_rnd_buffer 中
- 将 read_rnd_buffer 中的 id 进行递增排序
- 排序后的 id 数组,依次到主键 id 索引中查记录,并作为结果返回

read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的,8.x版本中大小为256k,如果满了,先排序再清空read_rnd_buffer,后续重复,如果想要稳定地使用 MRR 优化的话,需要设置`set optimizer_switch="mrr_cost_based=off"`

MRR 能够提升性能的核心在于,如果查询语句在二级索引  上做的是一个范围查询(也就是说,这是一个多值查询),可以得到足够多的主键 id; 这样通过排序以后,再去主键索引查数据,才能体现出"顺序性"的优势

## Batched Key Access

其是对NLJ(Index Nested-Loop Join) 算法的优化,MySQL 在 5.6 版本后开始引入的

### 启用BKA 优化算法

```mysql
-- BKA 算法的优化要依赖于 MRR
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
```

### BNL 算法的性能问题

使用 Block Nested-Loop Join(BNL) 算法时,可能会对被驱动表做多次扫描; 如果这个被驱动表是一个大的冷数据表,就可能出现问题,由于由于 InnoDB 对 Bufffer Pool 的 LRU 算法做了优化,即:第一次从磁盘读入内存的数据页,会先放在 old 区域; 如果 1 秒之后这个数据页不再被访问了,就不会被移动到 LRU 链表头部,这样对 Buffer Pool 的命中率影响就不大,但是,如果一个使用 BNL 算法的 join 语句,多次扫描一个冷表,而且这个语句执行时间超过 1 秒,就会在再次扫描冷表的时候,把冷表的数据页移到 LRU 链表头部

- 第一种情况是冷表的数据量小于整个 Buffer Pool 的 3/8,能够完全放入 old 区域的情况
- 第二种情况是如果冷表很大,业务正常访问的数据页,没有机会进入 young 区域

#### 影响

大表 join 操作虽然对 IO 有影响,但是在语句执行结束后,对 IO 的影响也就结束了; 但是,对 Buffer Pool 的影响就是持续性的,需要依靠后续的查询请求慢慢恢复内存命中率

- 可能会多次扫描被驱动表,占用磁盘 IO 资源
- 判断 join 条件需要执行 M*N 次对比(M、N 分别是两张表的行数),如果是大表就会占用非常多的 CPU 资源
- 可能会导致 Buffer Pool 的热数据被淘汰,影响内存命中率

#### 解决

- 可以增大 join_buffer_size 的值,从而减少对被驱动表的扫描次数

- 在执行语句前,可以通过理论分析和查看 explain 结果的方式,确认是否要使用 BNL 算法,如果优化器使用BNL算法,可以给被驱动表的 join 字段加上索引,把 BNL 算法转成 BKA 算法

存在一种情况,给某个字段创建索引收益很低,但是又不想使用BNL算法,可以使用临时表

- 将被驱动表的数据放到临时表中
- 给临时表的目标关联字段加上索引
- 让驱动表和临时表做join

不论是在原表上加索引,还是用有索引的临时表,思路都是让 join 语句能够用上被驱动表上的索引,来触发 BKA 算法,提升查询性能

## hash join

8.0.18引入,通过空间换时间,为小表建哈希表,扫描大表快速匹配
