[TOC]

示例表结构和数据

```mysql
create database db1;
use db1;

create table t(id int primary key, a int, b int, index(a))engine=innodb;
delimiter ;;
  create procedure idata()
  begin
    declare i int;
    set i=1;
    while(i<=1000)do
      insert into t values(i,i,i);
      set i=i+1;
    end while;
  end;;
delimiter ;
call idata();

create database db2;
create table db2.t like db1.t
```

## mysqldump 方法

使用 mysqldump 命令将数据导出成一组 INSERT 语句

```mysql
-- 把结果输出到临时文件
mysqldump -h$host -P$port -u$user -p$password --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a>900" --result-file=/client_tmp/t.sql
```

参数解析

- –single-transaction 的作用是,在导出数据的时候不需要对表 db1.t 加表锁,而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法(MySQL 中开启事务的特殊语法,主要用于在可重复读隔离级别下立即创建一个一致性读视图)
- –add-locks 设置为 0,表示在输出的文件结果里,不增加" LOCK TABLES t WRITE;"
- –no-create-info 的意思是,不需要导出表结构
- –set-gtid-purged=off 表示的是,不输出跟 GTID 相关的信息
- –result-file 指定了输出文件的路径,其中 client 表示生成的文件是在客户端机器上的

其中这样生成的 insert 语句中是批量插入多条语句的,如果想分开成多条insert语句的话,可以通过加上参数`–skip-extended-insert`

通过source命令执行语句

```mysql
mysql -h127.0.0.1 -P3306  -uroot -p$password db2 -e "source /client_tmp/t.sql"
```

特殊说明:source 并不是一条 SQL 语句,而是一个客户端命令,其执行流程是

- 打开文件,默认以分号为结尾读取一条条的 SQL 语句
- 将 SQL 语句发送到服务端执行

说下TRANSACTION WITH CONSISTENT SNAPSHOT

-  MySQL 中开启事务的特殊语法,主要用于在可重复读隔离级别下创建一个一致性读视图
- 与`START TRANSACTION`的区别是
  - 创建一致性快照时机不同,后者是第一次 SELECT 时创建,而前者是立即创建
  - 适用隔离级别不同,前者适用所有的隔离级别,而后者主要用在RR
  - MVCC 视图创建时机不同,前者延迟创建,而后者立即创建

说下LOCK TABLES t WRITE

是 MySQL 中的表级排他锁

- 锁定整个表:阻止其他所有会话的读写操作
- 获得排他访问权:只有当前会话可以读写该表
- 隐式提交事务:会提交当前活跃的事务

什么是GTID

Global Transaction Identifier,全局事务标识符,是 MySQL 5.6 引入的重要特性,它为每个提交的事务分配一个全局唯一且幂等的标识符

格式为 `source_id:transaction_id`, source_id 通常为 server_uuid ,可以使用 `SHOW VARIABLES LIKE 'server_uuid';` 查看,transaction_id 为事务在该实例上的序列号,从 1 开始递增

## 导出 CSV 文件

```mysql
-- 将查询结果导出到服务端本地目录
select * from db1.t where a>900 into outfile '/server_tmp/t.csv';
```

特殊说明

- 这条语句会将结果保存在服务端; 如果你执行命令的客户端和 MySQL 服务端不在同一个机器上,客户端机器的临时目录下是不会生成 t.csv 文件的
- into outfile 指定了文件的生成位置(/server_tmp/),这个位置必须受参数 secure_file_priv 的限制
- 这条命令不会帮你覆盖文件,因此你需要确保 /server_tmp/t.csv 这个文件不存在,否则执行语句时就会因为有同名文件的存在而报错
- 这条命令生成的文本文件中,原则上一个数据行对应文本文件的一行; 但是,如果字段中包含换行符,在生成的文本中也会有换行符; 不过类似换行符、制表符这类符号,前面都会跟上"\"这个转义符,这样就可以跟字段之间、数据行之间的分隔符区分开

得到.csv 导出文件后,可以用下面的 load data 命令将数据导入到目标表 db2.t 中

```mysql
load data infile '/server_tmp/t.csv' into table db2.t;
```

大致的执行流程

- 打开文件 /server_tmp/t.csv,以制表符 (\t) 作为字段间的分隔符,以换行符(\n)作为记录之间的分隔符,进行数据读取
- 启动事务
- 判断每一行的字段数与表 db2.t 是否相同:若不相同,则直接报错,事务回滚;若相同,则构造成一行,调用 InnoDB 引擎接口,写入到表中
- 重复步骤 3,直到 /server_tmp/t.csv 整个文件读入完成,提交事务

建议

- server_tmp 目录建议选择 `SHOW VARIABLES LIKE 'datadir';` 所在的路径 (避免一些权限问题)

- 同时要求目录必须存在,其不会自动创建子目录,如果'/server_tmp/export/t.csv'; 中的 export 目录不存在,也会写入失败

单独说下参数 secure_file_priv 的可选值和作用

- 如果设置为 empty,表示不限制文件生成的位置,这是不安全的设置
- 如果设置为一个表示路径的字符串,就要求生成的文件只能放在这个指定的目录,或者它的子目录
- 如果设置为 NULL,就表示禁止在这个 MySQL 实例上执行 select … into outfile 操作
- 查看 secure-file-priv 值 `SHOW VARIABLES LIKE 'secure_file_priv';`

需要在my.cnf 中配置secure_file_priv的值,其中my.cnf文件加载的优先顺序为(顺便说下,macos为my.cnf 而Windows下是my.ini)

```shell
mysqld --verbose --help | grep -A 20 "Default options"
Default options are read from the following files in the given order:
/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf
```

在主备的流程中,为了防止备库找不到导出的文件,以下是完成的流程

- 主库执行完成后,将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中
- 往 binlog 文件中写入语句 load data local infile '/tmp/SQL_LOAD_MB-1-0' INTO TABLE `db2`.`t`
- 把这个 binlog 日志传到备库
- 备库的 apply 线程在执行这个事务日志时
  - 先将 binlog 中 t.csv 文件的内容读出来,写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中
  - 再执行 load data 语句,往备库的 db2.t 表中插入跟主库相同的数据

load data 命令有两种用法

- 不加"local",是读取服务端的文件,这个文件必须在 secure_file_priv 指定的目录或子目录下
- 加上"local",读取的是客户端的文件,只要 mysql 客户端有访问这个文件的权限即可(MySQL 客户端会先把本地文件传给服务端,然后执行上述的 load data 流程)

注意的点

- select …into outfile 方法不会生成表结构文件,导数据时还需要单独的命令得到表结构定义
- mysqldump 提供了一个--tab 参数,可以同时导出表结构定义文件和 csv 数据文件

## 物理拷贝方法

mysqldump 方法和导出 CSV 文件的方法,都是逻辑导数据的方法

结论:直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下是不行的,因为,一个 InnoDB 表,除了包含这两个物理文件外,还需要在数据字典中注册; 直接拷贝这两个文件的话,因为数据字典中没有 db2.t 这个表,系统是不会识别和接受它们的

MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法,可以通过导出 + 导入表空间的方式,实现物理拷贝表的功能

需求:目标是在 db1 库下,复制一个跟表 t 相同的表 r(包括结构和数据)

- 执行 create table r like t,创建一个相同表结构的空表;
- 执行 alter table r discard tablespace,这时候 r.ibd 文件会被删除
- 执行 flush table t for export,这时候 db1 目录下会生成一个 t.cfg 文件
- 在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd;这两个命令
- 执行 unlock tables,这时候 t.cfg 文件会被删除
- 执行 alter table r import tablespace,将这个 r.ibd 文件作为表 r 的新的表空间,由于这个文件的数据内容和 t.ibd 是相同的,所以表 r 中就有了和表 t 相同的数据 (如果遇到1815 / Tablespace not found错误 ,同时db1目录下存在r.ibd 和 r.cfg 文件,请修改.ibd/.cfg 文件所属用户为`_mysql 用户`,所属组为`_mysql 组`)

```shell
sudo chown _mysql:_mysql r.ibd r.cfg
sudo chmod 660 r.ibd r.cfg
```

需要注意的点

- 执行完 flush table 命令之后,db1.t 整个表处于只读状态,直到执行 unlock tables 命令后才释放读锁(可以尝试插入数据,发现是阻塞等待)
- 在执行 import tablespace 的时候,为了让文件里的表空间 id 和数据字典中的一致,会修改 r.ibd 的表空间 id; 而这个表空间 id 存在于每一个数据页中; 因此,如果是一个很大的文件(比如 TB 级别),每个数据页都需要修改,所以你会看到这个 import 语句的执行是需要一些时间的
- 拷贝的文件需要目标数据库进程用户(如 `_mysql`)有读写权限,测试数据时可以使用root用户,但是切记不要随便修改 data 下文件权限,会影响 MySQL 启动

## 小结

- 物理拷贝的方式速度最快,尤其对于大表拷贝来说是最快的方法
- 用 mysqldump 生成包含 INSERT 语句文件的方法,可以在 where 参数增加过滤条件,来实现只导出部分数据; 这个方式的不足之一是,不能使用 join 这种比较复杂的 where 条件写法
- 用 select … into outfile 的方法是最灵活的,支持所有的 SQL 写法; 但,这个方法的缺点之一就是,每次只能导出一张表的数据,而且表结构也需要另外的语句单独备份

后两种方式都是逻辑备份方式,是可以跨引擎使用的,如果通过物理拷贝出现误删除的情况,用备份恢复出误删之前的临时库,然后再把临时库中的表拷贝到生产库上,是恢复数据最快的方法,但是存在局限性

- 物理文件是整个表的存储单元,不能只拷贝部分数据,如果只想恢复部分行或某些列,无法只操作文件,必须使用 SQL 导出/导入或逻辑恢复
- 需要到服务器上拷贝数据(访问数据库的物理存储路径),在用户无法登录数据库主机的场景下无法使用
- 由于是通过拷贝物理文件实现的(物理拷贝依赖 InnoDB 表空间文件,不同引擎的文件结构不同,直接拷贝会导致LSN、元数据会不一致),源表和目标表都是使用 InnoDB 引擎时才能使用