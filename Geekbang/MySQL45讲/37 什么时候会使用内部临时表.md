[TOC]

## 使用临时表的例子

临时表是一种二维表结构,有主键,有field; 所以如果中间数据需要用到二维表特性,那么就需要使用临时表,且内存临时表不够的前提下,会转为使用磁盘临时表

### union

explain Extra 字段 (Using temporary)

- 排序去重 (排好序移除重复项)
- 哈希去重
- 索引辅助去重

使用union all,因为不需要去重,所以直接将得到的结果直接作为结果集的一部分,不需要使用临时表

### group by

前言

MySQL 5.7 及之前GROUP BY 隐式包含 ORDER BY,而MySQL8.0之后不再隐式排序

## 临时表类型

- 内存临时表
- 磁盘临时表

内存临时表的大小是有限制的,参数 tmp_table_size 就是控制这个内存大小的,默认是 16M

```mysql
SHOW VARIABLES LIKE '%tmp_table%';
SHOW VARIABLES LIKE '%max_heap_table_size%';
```

如果结果集中的数据大小超过了这个大小,会使用磁盘临时表,磁盘临时表默认使用的引擎是 InnoDB

### 如何选择临时表类型

自动决策流程

1. 预估结果集大小
2. 与 tmp_table_size 和 max_heap_table_size 比较
3. 如果超过阈值 > 使用磁盘临时表(InnoDB)
4. 否则 > 使用内存临时表(MEMORY引擎)

### group by 优化方法

- 索引

无论是使用内存临时表还是磁盘临时表,group by 逻辑都需要构造一个带唯一索引的表,单列分组时,使用该列作为主键,多列分组,使用所有列作为复合主键,其中临时表主键是自动选择的,不能手动指定,而InnoDB 的索引,可以满足输入有序的条件,所以当计算 group by 的时候,就只需要从左到右,顺序扫描,依次累加,从而不需要临时表,也不需要再额外排序

- 直接排序

直接走磁盘临时表的方法,通过在 group by 语句中加入 SQL_BIG_RESULT,不会使用临时表,而会强制 MySQL 使用排序分组算法(如果 sort_buffer 内存不够用,就会利用磁盘临时文件辅助排序,使用`SHOW VARIABLES LIKE 'sort_buffer_size';`查看sort_buffer大小)然后根据有序数组,得到数组里面的不同值,以及每个值的出现次数,从而实现group by 的语义

## 总结

### 什么时候会使用临时表

- 如果语句执行过程可以一边读数据,一边直接得到结果,是不需要额外内存的,否则就需要额外的内存,来保存中间结果
- join_buffer 是无序数组,sort_buffer 是有序数组,临时表是二维表结构
- 如果执行逻辑需要用到二维表特性,就会优先考虑使用临时表,比如union需要用到唯一约束索引,group by 用到另外一个字段来存累积计数等等

### 什么时候会使用磁盘临时表

- 临时表超过内存限制(tmp_table_size/tmp_table_size两个参数)
- 字段类型不支持 MEMORY
- 需要排序但内存不够
- distinct + 大字段

### group by 的一些指导原则

- 如果对 group by 语句的结果没有排序要求,要在语句后面加 order by null
- 尽量让 group by 过程用上表的索引,确认方法是 explain 结果里没有 Using temporary 和 Using filesort
- 如果 group by 需要统计的数据量不大,尽量只使用内存临时表;也可以通过适当调大 tmp_table_size 参数,来避免用到磁盘临时表(避免使用磁盘临时表,是因为它会引入磁盘 I/O、B+Tree 维护、redo/undo 日志以及 buffer pool 污染等高昂成本,在 GROUP BY / ORDER BY 等高频操作中,性能可能下降一个数量级以上)
- 如果数据量实在太大,使用 SQL_BIG_RESULT 这个提示,来告诉优化器直接使用排序算法得到 group by 的结果
