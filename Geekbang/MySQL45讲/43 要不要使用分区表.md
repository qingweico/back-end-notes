[TOC]

## 分区表

创建表结构

```mysql
CREATE TABLE `t` (
  `ftime` datetime NOT NULL,
  `c` int(11) DEFAULT NULL,
  KEY (`ftime`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(ftime))
(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,
 PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,
 PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,
PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);
insert into t values('2017-4-1',1),('2018-4-1',1);
```

物理文件结构

```shell
-rw-r-----  1 _mysql  _mysql  131072  1月 19 14:26 t#p#p_2017.ibd
-rw-r-----  1 _mysql  _mysql  131072  1月 19 14:26 t#p#p_2018.ibd
-rw-r-----  1 _mysql  _mysql  131072  1月 19 14:26 t#p#p_2019.ibd
-rw-r-----  1 _mysql  _mysql  131072  1月 19 14:26 t#p#p_others.ibd
```

注:在MySQL 8.0 中.frm文件已移除,所有表结构元数据,统一存进 InnoDB 系统表(使用SHOW CREATE TABLE  查看),.ibd 文件存放 表数据 + 索引(不含表结构定义)

- 对于引擎层来说,这是 4 个表
- 对于 Server 层来说,这是 1 个表

## 分区表的引擎层行为

使用间隙锁来说明

### 实验组一

会话一执行

```mysql
BEGIN;
SELECT * FROM t WHERE ftime='2017-5-1' FOR UPDATE;
```

会话二执行

```mysql
-- 可以成功插入
insert into t values('2018-2-1', 1);
-- 会被阻塞
insert into t values('2017-12-1', 1);

```

### 对照组

使用普通表重复上面的操作

```mysql
-- 会被阻塞
insert into t1 values('2018-2-1', 1);

-- 可以成功插入
insert into t1 values('2018-5-1', 1);
```

说明下

- 表中有两条数据 [2017-4-1, 2018-4-1]
- 当使用普通表时,ftime 不是主键索引(普通索引),等值查询,RR级别,如上区间加上间隙锁
- 当插入2018-2-1会被阻塞,而位于区间之外的2018-5-1可以插入成功
- 当使用分区表时,对于引擎来说,p_2018 和 p_2019 是两个不同的表,2017-4-1 的下一个记录并不是 2018-4-1,而是 p_2018 分区的 supremum,所以实际锁定的范围是[2017-4-1, supremum],2018-2-1 不在范围内,所以可以插入成功,而2017-12-1在范围内,会被阻塞

### 实验组二

```mysql
-- 还是上面两条数据
TRUNCATE TABLE t
insert into t values('2017-4-1',1),('2018-4-1',1);

-- 会话一
BEGIN;
-- 锁定区间 p_2019 中的 [infimum, 2018-4-1]
SELECT * FROM t WHERE ftime='2018-3-1' FOR UPDATE;


-- 会话二

-- 阻塞
insert into t values('2018-2-1', 1);
-- 可以插入
insert into t values('2018-5-1', 1);
```

### 实验组三

```mysql
-- 还是上面两条数据
TRUNCATE TABLE t
insert into t values('2017-4-1',1),('2018-4-1',1);

-- 会话一
BEGIN;
-- 锁定区间 p_2019 中的 [2018-4-1, supremum]
SELECT * FROM t WHERE ftime='2018-5-1' FOR UPDATE;


-- 会话二

-- 阻塞
insert into t values('2018-6-1', 1);
-- 可以插入
insert into t values('2018-2-1', 1);
```

### 说下supremum,以及与之对应的 infimum

B+Tree 页内的"左右边界"(虚拟记录)

- infimum(页内最小边界)
- supremum(页内最大边界)

上面的边界是页界别的,而不是表级别的,即一张表有多少个索引页,就有多少个 supremum/infimum, 不存在全表唯一的supremum/infimum

例子

```shell
Page A:  [1, 3, 5]
Page B:  [7, 9, 11]
Page C:  [13, 15, 20]
```

执行 id > 9 for update

- 先说现象:直觉上是锁住了(9 ,+∞)的记录(各个区间上加 gap lock , 已存在的记录加上 record lock)
- 并不是真的加一个`(9, +∞)` 的"大锁",而是用"逐记录的 next-key lock + 页级 supremum gap lock"实现的
- 实际上是先通过 9 定位到 Page B,锁定 (9, 11), (11, supremum_B)
- 继续扫描 Page C,锁定 (infimum_C, 13),(13, 15),(15, 20),(20, supremum_C)
- 可以看到gap lock 是"页内加锁",但是由于页与页之间是通过链表指针相连,逻辑上覆盖了整个范围

### MyISAM引擎的表现

会话一

```mysql
alter table t engine=myisam;
update t set c=sleep(100) where ftime='2017-4-1';
```

会话二

```mysql
select * from t where ftime='2018-4-1'; (Query OK)
select * from t where ftime='2017-5-1'; (blocked)
```

原因:MyISAM 的表锁是在引擎层实现的,会话一加的表锁,其实是锁在分区 p_2018 上; 因此,只会堵住在这个分区上执行的查询,落到其他分区的查询是不受影响的

### 手动分表和分区表有什么区别

在性能上,手动分表和分区表并没有实质的差别,一个是由 server 层来决定使用哪个分区,一个是由应用层代码来决定使用哪个分表,从引擎层看,这两种方式也是没有差别的

### 分区策略

每当第一次访问一个分区表的时候,MySQL 需要把所有的分区都访问一遍; 一个典型的报错情况是这样的:如果一个分区表的分区很多,比如超过了 1000 个,而 MySQL 启动的时候,open_files_limit 参数使用的是默认值 1024,那么就会在访问这个表的时候,由于需要打开所有的文件,导致打开表文件的个数超过了上限而报错(使用 InnoDB 引擎的话,并不会出现这个问题,上面的问题出现在MyISAM 引擎)

发展历史

- MyISAM 分区表使用的分区策略,我们称为通用分区策略(generic partitioning),每次访问分区都由 server 层控制
- 从 MySQL 5.7.9 开始,InnoDB 引擎引入了本地分区策略(native partitioning); 这个策略是在 InnoDB 内部自己管理打开分区的行为
- MySQL 从 5.7.17 开始,将 MyISAM 分区表标记为即将弃用 (deprecated)
- 从 MySQL 8.0 版本开始,就不允许创建 MyISAM 分区表了(1178 - The storage engine for the table doesn't support native partitioning),只允许创建已经实现了本地分区策略的引擎(目前来看,只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略)

## 分区表的 server 层行为

从 server 层看的话,一个分区表就只是一个表

实验组

会话一

```mysql
begin;
select * from t where ftime='2018-4-1';
```

会话二

```mysql
-- 会被阻塞
alter table t truncate partition p_2017; 
```

原因:虽然 会话二只需要操作 p_2017 这个分区,但是由于 会话一 持有整个表 t 的 MDL 锁,就导致了会话二的 alter 语句被堵住

所以对于分区表和手动分表的选择,分区表是一张表,对表DDL操作的话会锁住所有的分区表,并发低,如果是自己从业务逻辑层分区,对一个表操作只是锁一个表

小结

- MySQL 在第一次打开分区表的时候,需要访问所有的分区
- 在 server 层,认为这是同一张表,因此所有分区共用同一个 MDL 锁(MDL(Metadata Lock)是 MySQL Server 层面的锁,而不是引擎层面的)
- 在引擎层,认为这是不同的表,因此 MDL 锁之后的执行过程,会根据分区表规则,只访问必要的分区(访问优化之分区剪裁,根据 SQL 的 WHERE 条件,只选择必要的分区去访问,其在 执行阶段就确定访问哪些分区)

## 分区表的应用场景

分区表的一个显而易见的优势是对业务透明,相对于用户分表来说,使用分区表的业务代码更简洁; 还有,分区表可以很方便的清理历史数据,比如日志表,流水表,审计表这种,本身就存在归档性质,有时效性,就比较适合分区表,删除也方便(通过alter table t drop partition xxx删掉分区,与使用 delete 语句删除数据相比,优势是速度快、对系统影响小)

## 小结

以上是范围分区,更多分区可以查询文档(https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html)

分区表跟用户分表比起来,有两个绕不开的问题:一个是第一次访问的时候需要访问所有分区,另一个是共用 MDL 锁,因此,如果要使用分区表,就不要创建太多的分区

- 分区并不是越细越好
- 分区也不要提前预留太多,在使用之前预先创建即可

其他问题

- 如果查询需要跨多个分区取数据,查询性能就会比较慢,基本上就不是分区表本身的问题,而是数据量的问题或者说是使用方式的问题
- 可以尝试一些成熟的分库分表中间件,用业务分表,相对来说有较小的复杂性,也更直观