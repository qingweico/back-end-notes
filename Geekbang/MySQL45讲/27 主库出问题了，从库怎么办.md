[TOC]

引言:大多数的互联网应用场景都是读多写少,如果遇到读性能的问题,在数据库层解决读性能问题,需要用到一主多从的架构

### 基于位点的主备切换

![一主多从基本结构](https://static001.geekbang.org/resource/image/aa/79/aadb3b956d1ffc13ac46515a7d619e79.png?wh=1142*856)

![一主多从主备切换](https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png?wh=1142*856)

A 和 A'互为主备, 一主多从的设置,一般用于读写分离,主库负责所有的写入和一部分读,其他的读请求则由从库分担,一主多从结构在切换完成后,A'会成为新的主库,从库 B、C、D 也要改接到 A'

下面是在一主多从架构下,主库故障后的主备切换问题

```mysql
-- 设置主库的从库时,需要执行的change master 命令(从库执行)
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
MASTER_LOG_FILE=$master_log_name 
MASTER_LOG_POS=$master_log_pos  
```

最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示,要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步,这个位置就是同步位点,也就是主库对应的文件名和日志偏移量

这个同步位点应该怎么确定

- 原来节点 B 是 A 的从库,本地记录的也是 A 的位点; 但是相同的日志,A 的位点和 A'的位点是不同的(这个位点很难精确取到,只能取一个大概位置)

其中一种取同步位点的方法

- 等待新主库 A'把中转日志(relay log)全部同步完成
- 在 A'上执行 show master status 命令,得到当前 A'上最新的 File 和 Position
- 取原主库 A 故障的时刻 T
- 用 mysqlbinlog 工具解析 A'的 File,得到 T 时刻的位点(end_log_pos 作为master_log_pos的值, 但是这个值并不精确)

不精确发生的场景

- 在某个时刻T, 主库 A 已经执行完成了一个 insert 语句插入了一行数据 R,并且已经将 binlog 传给了 A'和 B,然后在传完的瞬间主库 A 的主机就掉电
- 在从库 B 上,由于同步了 binlog, R 这一行已经存在
- 在新主库 A'上, R 这一行也已经存在,日志是写在T时刻位点这个位置之后的
- 在从库 B 上执行 change master 命令,指向 A'的 File 文件的位点,就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行
- 报主键冲突错误,停止同步

通常情况下,我们在切换任务的时候,要先主动跳过这些错误,有两种常用的方法

- 主动跳过一个事务(因为切换过程中,可能会不止重复执行一个事务)

```mysql
set global sql_slave_skip_counter=1;
start slave;
```

- 通过设置 slave_skip_errors 参数,直接设置跳过指定的错误

在执行主备切换时,有这么两类错误,是经常会遇到的

- 1062 错误是插入数据时唯一键冲突
- 1032 错误是删除数据时找不到行

注意的点:这种直接跳过指定错误的方法,针对的是主备切换时,由于找不到精确的同步位点,所以只能采用这种方法来创建从库和新主库的主备关系,等到主备间的同步关系建立完成,并稳定执行一段时间之后,需要把这个参数设置为空,以免之后真的出现了主从数据不一致,也跳过了

### mysqlbinlog 的使用

```mysql
-- 查看 binlog 文件所在路径
SHOW VARIABLES LIKE 'log_bin_basename';
-- 示例
mysqlbinlog --start-datetime="2026-01-15 10:00:00" --stop-datetime="2026-01-16 11:00:00"  /usr/local/mysql/data/binlog.000010;
```

```mysql
-- binlog 日志的内容
# The proper term is pseudo_replica_mode, but we use this compatibility alias
# to make the statement usable on server versions 8.0.24 and older.
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#260116 10:48:47 server id 1  end_log_pos 127 CRC32 0x1d5b3207 	Start: binlog v 4, server v 8.4.7 created 260116 10:48:47 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
D6dpaQ8BAAAAewAAAH8AAAABAAQAOC40LjcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAPp2lpEwANAAgAAAAABAAEAAAAYwAEGggAAAAAAAACAAAACgoKKioAEjQA
CigAAAEHMlsd
'/*!*/;
# at 127
#260116 10:48:47 server id 1  end_log_pos 158 CRC32 0x75f46cff 	Previous-GTIDs
# [empty]
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

``` mysql
-- MySQL 8.4.x 不支持如下命令 
SHOW MASTER STATUS;
=> -- 修改为
SHOW BINARY LOG STATUS;

SHOW SLAVE STATUS;
=> -- 修改为
SHOW REPLICA STATUS;

CHANGE MASTER TO
=> -- 修改为
CHANGE SOURCE TO
-- 查看 MySQL 版本等相关信息
SHOW VARIABLES LIKE 'version%';
```

### GTID

通过 sql_slave_skip_counter 跳过事务和通过 slave_skip_errors 忽略错误的方法,虽然都最终可以建立从库 B 和新主库 A'的主备关系,但这两种操作都很复杂,而且容易出错; 所以,MySQL 5.6 版本引入了 GTID,彻底解决了这个困难

GTID 的全称是 Global Transaction Identifier,也就是全局事务 ID,是一个事务在提交的时候生成的,是这个事务的唯一标识; 它由两部分组成,格式是 GTID=server_uuid:gno

在 MySQL 的官方文档里,GTID 格式是这么定义的

```mysql
-- source_id 就是 server_uuid;而后面的这个 transaction_id 就是 gno(但是这里使用事务id容易引起歧义)
GTID=source_id:transaction_id
```

- server_uuid 是一个实例第一次启动时自动生成的,是一个全局唯一的值
- gno 是一个整数,初始值是 1,每次提交事务的时候分配给这个事务,并加 1

说下 gno 和 transaction_id 的区别

- 在 MySQL 里面transaction_id 就是指事务 id,事务 id 是在事务执行过程中分配的,如果这个事务回滚了,事务 id 也会递增
- gno 是在事务提交的时候才会分配
- 它们两个都是递增,不同点是事务id自增但不一定连续,因为会被回滚,而gno在提交时分配,所以是连续递增的

#### GTID 模式的启动

启动一个 MySQL 实例的时候,加上参数 gtid_mode=on 和 enforce_gtid_consistency=on

在 GTID 模式下,每个事务都会跟一个 GTID 一一对应,这个 GTID 有两种生成方式,而使用哪种方式取决于 session 变量 gtid_next 的值

- 如果 gtid_next=automatic,代表使用默认值; 这时,MySQL 就会把 server_uuid:gno 分配给这个事务
  - 记录 binlog 的时候,先记录一行 SET @@SESSION.GTID_NEXT='server_uuid:gno'
  - 把这个 GTID 加入本实例的 GTID 集合
- 如果 gtid_next 是一个指定的 GTID 的值,比如通过 set gtid_next='current_gtid'指定为 current_gtid,那么就有两种可能
  - 如果 current_gtid 已经存在于实例的 GTID 集合中,接下来执行的这个事务会直接被系统忽略
  - 如果 current_gtid 没有存在于实例的 GTID 集合中,就将这个 current_gtid 分配给接下来要执行的事务,也就是说系统不需要给这个事务生成新的 GTID,因此 gno 也不用加 1

需注意的点:一个 current_gtid 只能给一个事务使用; 这个事务提交后,如果要执行下一个事务,就要执行 set 命令,把 gtid_next 设置成另外一个 gtid 或者 automatic

每个 MySQL 实例都维护了一个 GTID 集合,用来对应"这个实例执行过的所有事务"

#### 基于 GTID 的主备切换

在 GTID 模式下,备库 B 要设置为新主库 A'的从库的语法如下

```mysql
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password
-- 其中,master_auto_position=1 就表示这个主备关系使用的是 GTID 协议
-- MASTER_LOG_FILE 和 MASTER_LOG_POS 参数,已经不需要指定了
master_auto_position=1 
```

#### GTID 和在线 DDL

Online DDL, 考虑到要避免新增索引对主库性能造成的影响,可以先在备库加索引,然后再切换

- 在双 M 结构下,备库执行的 DDL 语句也会传给主库,为了避免传回后对主库造成影响,要通过 set sql_log_bin=off 关掉 binlog

使用 GTID

两个互为主备关系的库还是实例 X 和实例 Y,且当前主库是 X,并且都打开了 GTID 模式,此时的主备切换流程

- 在实例 X 上执行 stop slave
- 在实例 Y 上执行 DDL 语句; 注意,这里并不需要关闭 binlog
- 执行完成后,查出这个 DDL 语句对应的 GTID,并记为 server_uuid_of_Y:gno
- 到实例 X 上执行以下语句序列

```mysql
-- 通过提交一个空事务,把这个 GTID 加到实例 X 的 GTID 集合中
-- 让实例 X 跳过 DDL 的事务执行
-- 既让实例 Y 的更新有 binlog 记录,同时也可以确保不会在实例 X 上执行这条更新
set GTID_NEXT="server_uuid_of_Y:gno";
begin;
commit;
-- 恢复 GTID 的默认分配行为,如果之后有新的事务再执行,就还是按照原来的分配方式
set gtid_next=automatic;
start slave;
```

### 小结

MySQL 5.6 版本引入的 GTID 模式,一主多从切换就非常方便

问题:在 GTID 模式下设置主从关系的时候,从库执行 start slave 命令后,主库发现需要的 binlog 已经被删除掉了,导致主备创建不成功; 这种情况下,可以怎么处理呢

- 如果业务允许主从不一致的情况,那么可以在主库上先执行 show global variables like 'gtid_purged',得到主库已经删除的 GTID 集合,假设是 gtid_purged1;然后先在从库上执行 reset master,再执行 set global gtid_purged ='gtid_purged1';最后执行 start slave,就会从主库现存的 binlog 开始同步; binlog 缺失的那一部分,数据在从库上就可能会有丢失,造成主从不一致
- 如果需要主从数据一致的话,最好还是通过重新搭建从库来做
- 如果有其他的从库保留有全量的 binlog 的话,可以把新的从库先接到这个保留了全量 binlog 的从库,追上日志以后,如果有需要,再接回主库
- 如果 binlog 有备份的情况,可以先在从库上应用缺失的 binlog,然后再执行 start slave
