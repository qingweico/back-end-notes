[TOC]

### 加锁规则

两个规则和两个"优化"和一个"bug"

- 原则 1:加锁的基本单位是 next-key lock,next-key lock 是前开后闭区间
- 原则 2:查找过程中访问到的对象才会加锁
- 优化 1:索引上的等值查询,给唯一索引加锁的时候,next-key lock 退化为行锁
- 优化 2:索引上的等值查询,向右遍历时且最后一个值不满足等值条件的时候,next-key lock 退化为间隙锁
- 一个 bug:唯一索引上的范围查询会访问到不满足条件的第一个值为止

示例建表语句

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

### 不等号条件里的等值查询

```mysql
-- 会话一
begin;
select * from t where id>9 and id<12 order by id desc for update;

-- 会话二会被阻塞
INSERT INTO t(id, c, d) VALUES (2, 2, 2);
```

上面这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和 (10, 15),由于加锁单位是 next-key lock,都是前开后闭区间,为什么15这个边界不是闭区间呢,是因为使用到了上面的优化2:即索引上的等值查询,向右遍历的时候 id=15 不满足条件,所以 next-key lock 退化为了间隙锁 (10, 15)

关于等值查询:索引树的搜索方式定位具体位置(区间),然后遍历的方式查找范围

- 由于是 `order by id desc`,其会改变了索引的扫描方向,导致加锁范围扩大,如果没有`order by id desc`或者是 `order by id`, 区间(0,5]不会扫描到,即也不会加锁,会话二的语句就不会被阻塞
- 在索引树中找到最后一个 id < 12 的记录即 id=10的记录, 由于id = 12 这条记录不存在,所以12所在的这个区间被加锁,即找到了 (10,15) 这个间隙
- 然后向左遍历,在遍历过程中,就不是等值查询了,会扫描到 id=5 这一行,所以会加一个 next-key lock (0,5](为了找到"前一条"记录,向左扫描到 id=5,虽然 id=5 不满足 id>9,但扫描过程会经过它)
- 在向左扫描的过程中,会给经过的间隙加锁

### 等值查询的过程

```mysql
begin;
select id from t where c in(5,20,10) lock in share mode;
```

上述语句的加锁过程是什么

- c 有索引,但不是唯一索引
- 查找 c=5 的时候,先锁住了 (0,5],但是因为 c 不是唯一索引,为了确认还有没有别的记录 c=5,就要向右遍历,找到 c=10 才确认没有了,满足优化 2,所以加了间隙锁 (5,10)
- 执行 c=10 这个逻辑的时候,加锁的范围是 (5,10] 和 (10,15);执行 c=20 这个逻辑的时候,加锁的范围是 (15,20] 和 (20,25)
- 在索引 c 上加的三个记录锁的顺序是:先加 c=5 的记录锁,再加 c=10 的记录锁,最后加 c=20 的记录锁
- 锁是"在执行过程中一个一个加的",而不是一次性加上去的

```mysql
select id from t where c in(5,20,10) order by c desc for update;
```

- 这个语句中由于 `order by c desc`,所以这三个记录锁的加锁顺序,是先锁 c=20,然后 c=10,最后是 c=5,和最上面的语句放一块对比,由于这两条语句要加锁相同的资源,但是加锁顺序相反; 当这两条语句并发执行的时候,就可能出现死锁

### 如何查看死锁

- 查看 SHOW ENGINE INNODB STATUS(寻找LATEST DETECTED DEADLOCK)

- 打开死锁日志,SET GLOBAL innodb_print_all_deadlocks = ON;
- 通过performance_schema查看

```mysql
-- 当前锁等待
SELECT * FROM performance_schema.data_lock_waits;
-- 当前持有的锁
SELECT * FROM performance_schema.data_locks;
-- 查看当前所有正在执行的线程
SELECT 
  t.THREAD_ID,
  t.PROCESSLIST_ID,
  t.PROCESSLIST_INFO,
  t.PROCESSLIST_STATE,
  t.PROCESSLIST_TIME
FROM performance_schema.threads t
WHERE t.PROCESSLIST_INFO IS NOT NULL;
```

避免

- 由于锁是一个个加的,要避免死锁,对同一组资源,要按照尽量相同的顺序访问
- 在发生死锁的时刻,for update 这条语句占有的资源更多,回滚成本更大,所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句,来回滚

### 怎么看锁等待

#### 删除插入的例子

```mysql
-- 会话一
begin;
select * from t where id>10 and id<=15 for update;

-- 会话二
delete from t where id=10; -- (Query OK)
insert into t values(10,10,10); -- (blocked)
```

解释(重要!!!)

- 会话一中id > 10 为范围查询中的等值查询, 显然满足第二种情况,没有锁住 c=10 这个记录
  - 如果记录中不存在记录为10的行,对 `(prev_key, next_key)` 加 gap lock
  - 如果存在 `id = 10`,但该记录不满足查询条件,对 `(10, next_key)` 加 gap lock
  - 如果存在 `id = 10`,并且该记录满足查询条件,加next-key lock `(prev_key, 10]`
- 由于 delete 操作把 id=10 这一行删掉了,原来的两个间隙 (5,10)、(10,15)变成了一个 (5,15),加锁的范围"变大"了

总结

- 间隙是由(间隙)右边的记录定义的,如果本来一个间隙左边的(记录)被删除了,那么会往左扩大间隙
- 间隙锁和next key lock本质上还是行锁,比如(5,10]这个next key lock,可以描述为记录10上的next key lock
- next-key lock = record lock + 左侧 gap lock
- InnoDB 的锁是挂在索引记录上的,最终都依附在某条索引记录上,并不存在一个独立的区间锁对象
- 在索引记录 10 上加了 next-key lock, 锁住了区间 `(5,10]`(用来解释在区间中插入会被阻塞这一现象)

#### update 的例子

```mysql
-- 会话一
begin;
-- 注: 根据 c>5 查到的第一个记录是 c=10,因此不会加 (0,5]这个 next-key lock
-- 可以使用上面【解释】中的第二种情况解释,存在c等于5的记录,但是并不满足条件,所以对(5,next_key)加 gap lock
-- 加锁范围是索引 c 上的 (5,10]、(10,15]、(15,20]、(20,25]和 (25,supremum]
select c from t where c > 5 lock in share mode;

-- 会话二
update t set c = 1 where c = 5; -- (Query OK)
update t set c = 5 where c = 1; -- (blocked)
```

问题:一个空表有间隙吗?这个间隙是由谁定义的

空表中存在一个 `(−∞, +∞)` 的逻辑间隙,这个间隙不是由数据行定义的,而是由索引结构(B+Tree)的逻辑边界定义的