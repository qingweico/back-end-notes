[TOC]

## 内存表的数据组织结构

与 InnoDB 引擎不同,Memory 引擎的数据和索引是分开的,内存表的数据部分以数组的方式单独存放,而主键 id 索引里,存的是每个数据的位置; 主键 id 是 hash 索引,索引上的 key 并不是有序的, 读取数据,Memory 引擎按插入的顺序读取数据

InnoDB 和 Memory 引擎的数据组织方式是不同的

- InnoDB 引擎把数据放在主键索引上,其他索引上保存的是主键 id, 被称为索引组织表(Index Organizied Table)
- Memory 引擎采用的是把数据单独存放,索引上保存数据位置的数据组织形式,被称为堆组织表(Heap Organizied Table)

## 内存表对比Innodb

两者的区别

- InnoDB 表的数据总是有序存放的,而内存表的数据就是按照写入顺序存放的
- 当数据文件有空洞的时候,InnoDB 表在插入新数据的时候,为了保证数据有序性,只能在固定的位置写入新值,而内存表找到空位就可以插入新值
- 数据位置发生变化的时候,InnoDB 表只需要修改主键索引,而内存表需要修改所有索引
- InnoDB 表用主键索引查询时需要走一次索引查找,用普通索引查询的时候,需要走两次索引查找,而内存表没有这个区别,所有索引的"地位"都是相同的
- InnoDB 支持变长数据类型,不同记录的长度可能不同;内存表不支持 Blob 和 Text 字段,并且即使定义了 varchar(N),实际也当作 char(N),也就是固定长度字符串来存储,因此内存表的每行数据长度相同

所以对于删除内存表中的数据,不会产生数据空洞,空出的这个位置都可以被接下来要插入的数据复用

但是对于内存表执行范围查询,主键索引会使用不上(主键是hash规则存放,是无序的),需要走全表扫描;但是内存表也是支持 B-Tree 索引的,优化器会优先选择 B-Tree 索引

## 内存表的使用建议

虽然内存表的优势是速度快

- 读写内存比磁盘快
- 支持 hash 索引

但是仍然不建议在生产环境上使用内存表 因为

- 锁粒度问题(内存表不支持行锁,只支持表锁)
- 数据持久化问题(数据库重启的时候,所有的内存表都会被清空(主要是主从复制时会受到影响))

内存表执行速度快的优势相比 Innodb 体现不出来 如下

- 如果表更新量大,那么并发度是一个很重要的参考指标,InnoDB 支持行锁,并发度比内存表好
- 能放到内存表的数据量都不大; 如果考虑的是读的性能,一个读 QPS 很高并且数据量不大的表,即使是使用 InnoDB,数据也是都会缓存在 InnoDB Buffer Pool 里的; 因此,使用 InnoDB 表的读性能也不会差

所以,可以建议把普通内存表都用 InnoDB 表来代替,但是除了下面一个场景

- 在数据量可控,不会耗费过多内存的情况下,可以考虑使用内存表

## 小结

- 由于重启会丢数据,如果一个备库重启,会导致主备同步线程停止;如果主库跟这个备库是双 M 架构,还可能导致主库的内存表数据被删掉,因此,在生产上,不建议你使用普通内存表
- InnoDB 表性能还不错,而且数据安全也有保障; 而内存表由于不支持行锁,更新语句会阻塞查询,性能也未必就如想象中那么好
- 基于内存表的特性,它的一个适用场景,就是内存临时表; 内存表支持 hash 索引,这个特性利用起来,对复杂查询的加速效果还是很不错的