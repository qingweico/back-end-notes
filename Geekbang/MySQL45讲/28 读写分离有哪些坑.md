[TOC]

一主多从架构的应用场景:读写分离,以及怎么处理主备延迟导致的读写分离问题

### 读写分离的基本结构

读写分离的主要目标就是分摊主库的压力, 下面的架构模式是客户端(client)主动做负载均衡,这种模式下一般会把数据库的连接信息放在客户端的连接层; 也就是说,由客户端来选择后端数据库进行查询

![读写分离基本结构](https://static001.geekbang.org/resource/image/13/aa/1334b9c08b8fd837832fdb2d82e6b0aa.png?wh=1142*637)

还有一种架构是,在 MySQL 和客户端之间有一个中间代理层 proxy,客户端只连接 proxy, 由 proxy 根据请求类型和上下文决定请求的分发路由

![带 proxy 的读写分离架构](https://static001.geekbang.org/resource/image/1b/45/1b1ea74a48e1a16409e9b4d02172b945.jpg?wh=1142*668)

客户端直连和带 proxy 的读写分离架构,各有哪些特点

- 客户端直连方案,因为少了一层 proxy 转发,所以查询性能稍微好一点儿,并且整体架构简单,排查问题更方便; 但是这种方案,由于要了解后端部署细节,所以在出现主备切换、库迁移等操作的时候,客户端都会感知到,并且需要调整数据库连接信息
- 带 proxy 的架构,对客户端比较友好; 客户端不需要关注后端细节,连接维护、后端信息维护等工作,都是由 proxy 完成的,proxy 也需要有高可用架构; 因此,带 proxy 架构的整体就相对比较复杂

### 主备延迟导致过期读

由于主从可能存在延迟,客户端执行完一个更新事务后马上发起查询,如果查询选择的是从库的话,就有可能读到刚刚的事务更新之前的状态,这种"在从库上会读到系统的一个过期状态"的现象,可以称之为"过期读"

因为事实确实存在几种主备延迟的原因,以及存在优化策略,但是主从延迟还是不能 100% 避免的

### 解决方案

#### 强制走主库方案

强制走主库方案其实就是,将查询请求做分类

- 对于必须要拿到最新结果的请求,强制将其发到主库上
- 对于可以读到旧数据的请求,才将其发到从库上

#### Sleep 方案

主库更新后,读从库之前先 sleep 一下(这个方案的假设是,大多数情况下主备延迟在 1 秒之内,做一个 sleep 可以有很大概率拿到最新的数据)

这个 sleep 方案确实解决了类似场景下的过期读问题; 但,从严格意义上来说,这个方案存在的问题就是不精确

- 如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果,也会等 1 秒
- 如果延迟超过 1 秒,还是会出现过期读

#### 判断主备无延迟方案

- seconds_behind_master 参数的值,可以用来衡量主备延迟时间的长短,每次从库执行查询请求前,先判断 seconds_behind_master 是否已经等于 0; 如果还不等于 0 ,那就必须等到这个参数变为 0 才能执行查询请求(由于其单位是秒,如果觉得精度不够的话,还可以采用对比位点和 GTID 的方法来确保主备无延迟)
- 对比位点确保主备无延迟

```mysql
-- Master_Log_File 和 Read_Master_Log_Pos,表示的是读到的主库的最新位点
Master_Log_File: mysql-bin.000007
Read_Master_Log_Pos: 1053
-- Relay_Master_Log_File 和 Exec_Master_Log_Pos,表示的是备库执行的最新位点
Relay_Master_Log_File: mysql-bin.000007
Exec_Master_Log_Pos: 1053
```

如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同,就表示接收到的日志已经同步完成

- 对比 GTID 集合确保主备无延迟

```mysql
-- 表示这对主备关系使用了 GTID 协议
Auto_Position=1
-- 是备库收到的所有日志的 GTID 集合
Retrieved_Gtid_Set
-- 是备库所有已经执行完成的 GTID 集合
Executed_Gtid_Set
-- 如果这两个集合相同,也表示备库接收到的日志都已经同步完成
```

可见,对比位点和对比 GTID 这两种方法,都要比判断 seconds_behind_master 是否为 0 更准确

在执行查询请求之前,先判断从库是否同步完成的方法,相比于 sleep 方案,准确度确实提升了不少,但还是没有达到"精确"的程度, 原因是一个事务的 binlog 在主备库之间可能存在状态差异

- 主库执行完成,写入 binlog,并反馈给客户端
- binlog 被从主库发送给备库,备库收到
- 在备库执行 binlog 完成

如果部分日志,处于客户端已经收到提交确认,而备库还没收到日志的状态(也可以说:主库还没有将日志传到从库中),而此时客户端执行查询就还是会出现过期读

#### 配合 semi-sync

半同步复制(semi-sync replication)

semi-sync 做了这样的设计

- 事务提交的时候,主库把 binlog 发给从库
- 从库收到 binlog 以后,发回给主库一个 ack,表示收到了
- 主库收到这个 ack 以后,才能给客户端返回"事务完成"的确认

如果启用了 semi-sync,就表示所有给客户端发送过确认的事务,都确保了备库已经收到了这个日志,semi-sync 配合前面关于位点的判断,就能够确定在从库上执行的查询请求,可以避免过期读

但是,semi-sync+ 位点判断的方案,只对一主一备的场景是成立的; 在一主多从场景中,主库只要等到一个从库的 ack,就开始给客户端返回确认; 这时,在从库上执行查询请求,就有两种情况

- 如果查询是落在这个响应了 ack 的从库上,是能够确保读到最新数据
- 但如果是查询落到其他从库上,它们可能还没有收到最新的日志,就会产生过期读的问题

其实,判断同步位点的方案还有另外一个潜在的问题,即:如果在业务更新的高峰期,主库的位点或者 GTID 集合更新很快,那么上面的两个位点等值判断就会一直不成立,很可能出现从库上迟迟无法响应查询请求的情况

semi-sync 配合判断主备无延迟的方案,存在两个问题

- 一主多从的时候,在某些从库执行查询请求会存在过期读的现象
- 在持续延迟的情况下,可能出现过度等待的问题

#### 等主库位点方案

```mysql
select master_pos_wait(file, pos[, timeout]);
```

这条命令的逻辑

- 它是在从库执行的
- 参数 file 和 pos 指的是主库上的文件名和位置
- timeout 可选,设置为正整数 N 表示这个函数最多等待 N 秒
- 这个命令正常返回的结果是一个正整数 M,表示从命令开始执行,到应用完 file 和 pos 表示的 binlog 位置,执行了多少事务
  - 如果执行期间,备库同步线程发生异常,则返回 NULL
  - 如果等待超过 N 秒,就返回 -1
  - 如果刚开始执行的时候,就发现已经执行过这个位置了,则返回 0

按照设定不允许过期读的要求,就只有两种选择,一种是超时放弃,一种是转到主库查询

#### GTID 方案

```mysql
 -- 需要数据库开启 GTID 模式
 select wait_for_executed_gtid_set(gtid_set, 1);
```

这条命令的逻辑是

- 等待,直到这个库执行的事务中包含传入的 gtid_set,返回 0
- 超时返回 1

在前面等位点的方案中,我们执行完事务后,还要主动去主库执行 show master status; 而 MySQL 5.7.6 版本开始,允许在执行完更新类事务后,把这个事务的 GTID 返回给客户端,这样等 GTID 的方案就可以减少一次查询

让MySQL 在执行事务后,返回包中带上 GTID的办法: 将参数 session_track_gtids 设置为 OWN_GTID,然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值

### 小结

在实际应用中,这几个方案是可以混合使用的:可以先在客户端对请求做分类,区分哪些请求可以接受过期读,而哪些请求完全不能接受过期读;然后,对于不能接受过期读的语句,再使用等 GTID 或等位点的方案

过期读在本质上是由一写多读导致的; 在实际应用中,可能会有别的不需要等待就可以水平扩展的数据库方案,但这往往是用牺牲写性能换来的,也就是需要在读性能和写性能中取权衡