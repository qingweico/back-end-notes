### 全字段排序

“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer

对 sort_buffer 中的数据按照字段做快速排序

这个排序过程，称为全字段排序

排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size

但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序

外部排序一般使用归并排序算法

MySQL 将需要排序的数据分成多份，每一份单独排序后存在这些临时文件中。然后把这多个有序文件再合并成一个有序的大文件

如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成; 否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大

### rowid 排序

```mysql
SET max_length_for_sort_data = 16;
```

max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法

对 sort_buffer 中的数据按照字段进行排序；遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出需要的字段返回给客户端

实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到需要的字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的

### 全字段排序 VS rowid 排序

如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据

如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据

如果内存够，就要多利用内存，尽量减少磁盘访问

对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择

MySQL 做排序是一个成本比较高的操作

其实，并不是所有的 order by 语句，都需要排序操作的

MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的

创建一个联合索引

这个查询过程不需要临时表，也不需要排序

优化: 使用覆盖索引; 覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据