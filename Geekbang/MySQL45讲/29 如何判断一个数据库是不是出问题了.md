[TOC]

### select 1 判断

复现数据库语句

```mysql
set global innodb_thread_concurrency=3;
-- 三个会话执行查询
SELECT sleep(100) FROM t;
-- 可以执行成功
select 1;
-- 会被阻塞
SELECT *  FROM t;
-- 所以这个时候用 select 1 来检测实例是否正常的话,是检测不出问题的
```

- 设置 innodb_thread_concurrency 参数的目的是,控制 InnoDB 的并发线程上限
- 一旦并发线程数达到这个值,InnoDB 在接收到新请求的时候,就会进入等待状态,直到有线程退出
- SLEEP() 函数会对查询结果中的每一行都执行一次睡眠(实际睡眠时间 = SLEEP(参数) × 表行数)
- 在 InnoDB 中,innodb_thread_concurrency 这个参数的默认值是 0,表示不限制并发线程数量(通常把 innodb_thread_concurrency 设置为 64~128 之间的值)

分清楚并发连接和并发查询

- show processlist 的结果里,显示的是并发连接
- 当前正在执行的指的才是并发查询
- 并发连接数达到几千个影响并不大,就是多占一些内存而已,而真正影响CPU的是并发查询,所以要限制innodb_thread_concurrency的大小,而不是默认值0

问题:并发更新同一行数据时,innodb_thread_concurrency数量是不是很快就会被消耗完吗

在线程进入锁等待以后,并发线程的计数会减一,也就是说等行锁(也包括间隙锁)的线程是不算在innodb_thread_concurrency 里面的,MySQL 这样设计是非常有意义的; 因为,进入锁等待的线程已经不吃 CPU 了;更重要的是,必须这么设计,才能避免整个系统锁死

虽然说等锁的线程不算在并发线程计数里,但如果它在真正地执行查询,如上面的示例查询,还是要算进并发线程的计数的,上面的示例说明了,通过 select 1 来检测系统,会认为系统还是正常的,但是实际上系统其实已经不行了

### 查表判断

为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况,需要找一个访问 InnoDB 的场景; 一般的做法是,在系统库(mysql 库)里创建一个表,比如命名为 health_check,里面只放一行数据,然后定期执行,使用这个方法,我们可以检测出由于并发线程过多导致的数据库不可用的情况
