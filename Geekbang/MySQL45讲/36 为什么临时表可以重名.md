[TOC]

首先临时表和内存表是两个不同的概念

- 内存表,指的是使用 Memory 引擎的表,在创建表时候指定engine=memory,这种表的数据都保存在内存里,系统重启的时候会被清空,但是表结构还在
- 临时表,可以使用各种引擎类型 ; 如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表,写数据的时候是写到磁盘上的; 当然,临时表也可以使用 Memory 引擎

### 临时表的特性

- 简表语句是create temporary table
- 一个临时表只能被创建它的 session 访问,对其他线程不可见
- 临时表可以与普通表同名
- 会话内有同名的临时表和普通表的时候,show create 语句,以及增删改查语句访问的是临时表
- show tables 命令不显示临时表

由于临时表只能被创建它的会话访问,所以在这个会话结束的时候,会自动删除临时表

### 临时表的应用

- join优化
- 分库分表系统的跨库查询

为什么

- 不同 session 的临时表是可以重名的,如果有多个 session 同时执行 join 优化,不需要担心表名重复导致建表失败的问题
- 不需要担心数据删除问题; 如果使用普通表,在流程执行过程中客户端发生了异常断开,或者数据库发生异常重启,还需要专门来清理中间过程中生成的数据表; 而临时表由于会自动回收,所以不需要这个额外的操作

### 为什么临时表可以重名

保存数据和保存表结构

#### 物理区分

- MySQL 要给 InnoDB 表创建一个 frm 文件保存表结构定义,这个frm 文件放在临时文件目录下,文件名的后缀是.frm,前缀是"#sql{进程 id}_{线程 id}_ 序列号,可以使用 `select @@tmpdir` 命令,来显示实例的临时文件目录
- - 在 5.6 以及之前的版本里,MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件,用来存放数据文件
  - 而从 5.7 版本开始,MySQL 引入了一个临时文件表空间,专门用来存放临时文件的数据

#### 内存区分

每个表都对应一个 table_def_key

- 一个普通表的 table_def_key 的值是由"库名 + 表名"得到的,所以如果你要在同一个库下创建两个同名的普通表,创建第二个表的过程中就会发现 table_def_key 已经存在了
- 而对于临时表,table_def_key 在"库名 + 表名"基础上,又加入了"server_id+thread_id"

所以不同的会话中,创建的两个临时表 ,它们的 table_def_key 不同,磁盘文件名也不同,因此可以并存

在实现上,每个线程都维护了自己的临时表链表; 这样每次 session 内操作表的时候,先遍历链表,检查是否有这个名字的临时表,如果有就优先操作临时表,如果没有再操作普通表;在 session 结束的时候,对链表里的每个临时表,执行 "DROP TEMPORARY TABLE + 表名"操作

### 临时表和主备复制

如果当前的 binlog_format=row,那么跟临时表有关的语句,就不会记录到 binlog 里; 也就是说,只在 binlog_format=statment/mixed 的时候,binlog 中才会记录临时表的操作

这种情况下,创建临时表的语句会传到备库执行,因此备库的同步线程就会创建这个临时表; 主库在线程退出的时候,会自动删除临时表,但是备库同步线程是持续在运行的; 所以,这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行

#### 改写问题

因为drop table xxx 相对其他的 DDL, 后面可以加多个表,所以为了保证 binlog日志在从库完成以下目标

- 从库一定能执行成功
- 执行结果与主库一致
- 执行行为是确定的

上面说到当binlog_format=row时,临时表相关的不会记录到日志,但是如果要 drop 的表中有 临时表,必要将其移出掉,所以,drop table 命令记录 binlog 的时候,就必须对语句做改写

再说下binlog日志

binlog 中保持的语意是 不是"你做了什么,而是"从库应该做什么,才能和主库一样"

#### 从库处理同名的临时表

备库的应用日志线程是共用的,所以在从库中可能(为什么是可能,因为有多线程复制)会出现同一个线程处理同名的临时表

先回忆下主从复制的过程

- IO Thread   → Relay Log → SQL Thread(单线程)(5.6及其之前)
- IO Thread → Relay Log → Coordinator → Worker Threads (N) (5.6 之后)

备库(Replica)的中继日志(Relay Log)是可以多线程并行回放的,通过配置参数`SET GLOBAL slave_parallel_workers = xxx;`  但是其并不是随便并行,而是受到严格调度规则限制

回到上述的问题,MySQL是这样解决的

MySQL 在记录 binlog 的时候,会把主库执行这个语句的线程 id 写到 binlog 中; 这样,在备库的应用线程就能够知道执行每个语句的主库线程 id,并利用这个线程 id 来构造临时表的 table_def_key,所以由于 table_def_key 不同,所以这两个表在备库的应用线程里面是不会冲突的

### 小结

在实际应用中,临时表一般用于处理比较复杂的计算逻辑; 由于临时表是每个线程自己可见的,所以不需要考虑多个线程执行同一个处理逻辑时,临时表的重名问题; 在线程退出的时候,临时表也能自动删除,省去了收尾和异常处理的工作

在 binlog_format='row'的时候,临时表的操作不记录到 binlog 中,也省去了不少麻烦,这也可以成为你选择 binlog_format 时的一个考虑因素

其中,用户通过 create temporary table 创建的被称为用户临时表,与之对应的是内部临时表