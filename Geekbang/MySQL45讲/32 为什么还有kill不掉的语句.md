[TOC]

## kill命令

在 MySQL 中有两个 kill 命令,其终止检查点类似 Java的Safepoint,目的是安全终止查询,其需要依靠特定的"埋点"实现

- 一个是 kill query + 线程 id,表示终止这个线程中正在执行的语句
- 一个是 kill connection + 线程 id,这里 connection 可缺省,表示断开这个线程的连接,当然如果这个线程有语句正在执行,也是要先停止正在执行的语句的

收到 kill 以后,线程做什么

- kill 并不是马上停止的意思
- 先修改状态(THD::KILL_QUERY)
- 再给目标执行线程发送信号

为什么要这么做

- 一个语句执行过程中有多处"埋点",在这些"埋点"的地方判断线程状态,如果发现线程状态是 THD::KILL_QUERY,才开始进入语句终止逻辑
- 如果处于等待状态,必须是一个可以被唤醒的等待,否则根本不会执行到"埋点"处
- 语句从开始进入终止逻辑,到终止逻辑完全完成,是有一个过程的

当执行 show processlist 时 如果一个线程的状态是KILL_CONNECTION,就把Command列显示成Killed

kill 无效的第一类情况

- 线程没有执行到判断线程状态的逻辑
- 由于 IO 压力过大,读写 IO 的函数一直无法返回,导致不能及时判断线程的状态

kill 无效的第二类情况(终止逻辑耗时较长)

- 超大事务执行期间被 kill; 这时候,回滚操作需要对事务执行期间生成的所有新数据版本做回收操作,耗时很长
- 大查询回滚; 如果查询过程中生成了比较大的临时文件,加上此时文件系统压力大,删除临时文件可能需要等待 IO 资源,导致耗时较长
- DDL 命令执行到最后阶段,如果被 kill,需要删除中间过程的临时文件,也可能受 IO 资源影响耗时较久

## 其他关于客户端的误解

### 客户端通过 Ctrl+C 命令终止线程

直接在客户端通过 Ctrl+C 命令,不可以直接终止线程,因为在客户端的操作只能操作到客户端的线程,客户端和服务端只能通过网络交互,是不可能直接操作服务端线程的,而由于 MySQL 是停等协议,所以这个线程执行的语句还没有返回的时候,再往这个连接里面继续发命令也是没有用的,实际上,执行 Ctrl+C 的时候,是 MySQL 客户端另外启动一个连接,然后发送一个 kill query 命令

### 如果库里面的表特别多,连接就会很慢

每个客户端在和服务端建立连接的时候,需要做的事情就是 TCP 握手、用户校验、获取权限; 但这几个操作,显然跟库里面表的个数无关

原因

- 当使用默认参数连接的时候,MySQL 客户端会提供一个本地库名和表名补全的功能
- 首先执行 show databases,切换到目标库, 执行 show tables,然后把这两个命令的结果用于构建一个本地的哈希表
- 其中构建哈希表的过程比较耗时,所以,当一个库中的表个数非常多的时候,这一步就会花比较长的时间,所以感知到的连接过程慢,其实并不是连接慢,也不是服务端慢,而是客户端慢

解决

- 连接命令中加上 -A,就可以关掉这个自动补全的功能,然后客户端就可以快速返回了

### –quick参数(-q)

其并不是可以让服务端加速的参数,相反设置了该参数可能会降低服务端的性能

首先MySQL 客户端发送请求后,接收服务端返回结果的方式有两种

- 一种是本地缓存,也就是在本地开一片内存,先把结果存起来,对应的api是mysql_store_result
- 另一种是不缓存,读一个处理一个,对应的api是mysql_use_result

MySQL 客户端默认采用第一种方式,而如果加上–quick 参数,就会使用第二种不缓存的方式,所以当采用不缓存的方式时,如果本地处理得慢,就会导致服务端发送结果被阻塞,因此会让服务端变慢

至于为什么参数的名字叫做 quick,是因为以下的三个原因让客户端变得更快

- 跳过表名自动补全功能(上面的-A功能)
- mysql_store_result 需要申请本地内存来缓存查询结果,如果查询结果太大,会耗费较多的本地内存,可能会影响客户端本地机器的性能
- 是不会把执行命令记录到本地的命令历史文件

## 小结

"kill 不掉"的情况,其实是因为发送 kill 命令的客户端,并没有强行停止目标线程的执行,而只是设置了个状态,并唤醒对应的线程,而被 kill 的线程,需要执行到判断状态的"埋点",才会开始进入终止逻辑阶段; 并且,终止逻辑本身也是需要耗费时间的,所以当发现一个线程处于 Killed 状态,可以通过改变系统状态,让Killed 状态尽快结束(比如修改参数、减少系统压力),做完这些只能等待流程自己完成

