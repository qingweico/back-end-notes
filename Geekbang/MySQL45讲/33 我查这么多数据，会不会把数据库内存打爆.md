[TOC]

## 全表扫描对 server 层的影响

- InnoDB 的数据是保存在主键索引上的,所以全表扫描实际上是直接扫描表 t 的主键索引
- 实际上,服务端并不需要保存一个完整的结果集  大致流程是
  - 获取一行,写到 net_buffer 中; 这块内存的大小是由参数 net_buffer_length 定义的,默认是 16k
  - 重复获取行,直到 net_buffer 写满,调用网络接口发出去
  - 如果发送成功,就清空 net_buffer,然后继续取下一行,并写入 net_buffer
  - 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK,就表示本地网络栈(socket send buffer)写满了,进入等待; 直到网络栈重新可写,再继续发送
- 所以一个查询在发送过程中,占用的 MySQL 内部的内存最大就是 net_buffer_length
- 而socket send buffer的大小也不会达到物理内存的大小,如果 socket send buffer 被写满,就会暂停读数据的流程
- 所以说MySQL 是"边读边发的",如果客户端接收得慢,会导致 MySQL 服务端由于结果发不出去,这个事务的执行时间变长
- 如果 `show processlist` 中 State 的结果为 `Sending to client` 就表示服务器端的网络栈写满了
- 还有一种状态是 Sending data,仅当一个线程处于"等待客户端接收结果"的状态,才会显示"Sending to client";而如果显示成"Sending data",它的意思只是"正在执行"(并不一定是指"正在发送数据",而可能是处于执行器过程中的任意阶段,比如锁等待的场景)
- 将 net_buffer_length 参数设置为一个更大的值,可以快速减少处于 Sending to client" 状态的线程

总结:

查询的结果是分段发给客户端的,因此扫描全表,查询返回大量的数据,并不会把内存打爆

## 全表扫描对 InnoDB 的影响

前言:

### WAL 机制

- InnoDB 内存的一个作用,是保存更新的结果,再配合 redo log,就避免了随机写盘
- 内存的数据页是在 Buffer Pool (BP) 中管理的,在 WAL 里 Buffer Pool 起到了加速更新的作用; 而实际上,Buffer Pool 还有一个更重要的作用,就是加速查询
- 由于有 WAL 机制,当事务提交的时候,磁盘上的数据页是旧的,当有一个查询要来读这个数据页,不需要马上把 redo log 应用到数据页,因为这时候内存数据页的结果是最新的,直接读内存页就可以了

### 内存命中率

- Buffer Pool 对查询的加速效果,依赖于一个重要的指标,就是内存命中率

- 内存命中率也可以说的是缓冲池命中率(Buffer Pool Hit Rate),这是衡量InnoDB性能的关键指标
- InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的,一般建议设置成可用物理内存的 60%~80%

### LRU

InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU) 算法,这个算法的核心就是淘汰最久未使用的数据,是用链表来实现的,其节点存放的是数据页

#### 问题

但是会存在问题,如果某次扫描一个冷门的历史数据表,按照这个算法逻辑,就会把当前的 Buffer Pool 里的数据全部淘汰掉,存入扫描过程中访问到的数据页的内容; 也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据,此时 Buffer Pool 的内存命中率急剧下降,磁盘压力增加,SQL 语句响应变慢,所以,InnoDB 不能直接使用这个 LRU 算法; 实际上,InnoDB 对 LRU 算法做了改进

#### 改进

在 InnoDB 实现上,按照 5:3 的比例把整个 LRU 链表分成了 young(前5) 区域和 old(后3) 区域

不同点

- 新插入的节点会放在 old 头部
- 每次访问做判断 若该节点在链表中存在的时间超过了 1 秒,就把它移动到链表头部,短于 1 秒,位置保持不变
- 时间由参数 innodb_old_blocks_time 控制的; 其默认值是 1000,单位毫秒
- 所以对于这些冷门数据的全表扫描,最后一次访问即第一次访问,时间间隔不会超过 1 秒,在扫描后续的数据时,之前的这个数据页之后也不会再被访问到,这些数据页始终没有机会移到链表头部(也就是 young 区域)一直在old 区域,很快就会被淘汰出去

在扫描这个大表的过程中,虽然也用到了 Buffer Pool,但是对 young 区域完全没有影响,从而保证了 Buffer Pool 响应正常业务的查询命中率

## 总结

由于 MySQL 采用的是边算边发的逻辑,因此对于数据量很大的查询结果来说,不会在 server 端保存完整的结果集; 所以,如果客户端读结果不及时,会堵住 MySQL 的查询过程,但是不会把内存打爆

对于 InnoDB 引擎内部,由于有淘汰策略,大查询也不会导致内存暴涨; 并且,由于 InnoDB 对 LRU 算法做了改进,冷数据的全表扫描,对 Buffer Pool 的影响也能做到可控

全表扫描还是比较耗费 IO 资源的,所以业务高峰期还是不能直接在线上主库执行全表扫描的