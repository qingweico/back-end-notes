[TOC]

只要主库执行更新生成的所有 binlog,都可以传到备库并被正确地执行,备库就能达到跟主库一致的状态,这就是最终一致性,但是,MySQL 要提供高可用能力,只有最终一致性是不够的

## 主备延迟

主备切换可能是一个主动运维动作,比如软件升级、主库所在机器按计划下线等,也可能是被动操作,比如主库所在机器掉电

与数据同步有关的时间点主要包括以下三个

- 主库 A 执行完成一个事务,写入 binlog 计为 T1 时刻
- 之后传给备库 B,把备库 B 接收完这个 binlog 的时刻记为 T2
- 备库 B 执行完成这个事务,把这个时刻记为 T3

所谓主备延迟,就是同一个事务,在备库执行完成的时间和主库执行完成的时间之间的差值,也就是 T3-T1

可以在从库中执行 `show slave status` 命令,找到 `seconds_behind_master` 属性,其表示的就是当前备库延迟了多少秒

计算方法是

- 每个事务的 binlog 里面都有一个时间字段,用于记录主库上写入的时间
- 备库取出当前正在执行的事务的时间字段的值,计算它与当前系统时间的差值,得到 seconds_behind_master

问题:如果主备库机器的系统时间设置不一致,会不会导致主备延迟的值不准

不会的; 因为,备库连接到主库的时候,会通过执行 SELECT UNIX_TIMESTAMP() 函数来获得当前主库的系统时间; 如果这时候发现主库的系统时间与自己不一致,备库在执行 seconds_behind_master 计算的时候会自动扣掉这个差值

在网络正常的时候,日志从主库传给备库所需的时间是很短的,主备延迟的主要来源是备库接收完 binlog 和执行完这个事务之间的时间差,所以说,主备延迟最直接的表现是,备库消费中转日志(relay log)的速度,比主库生产 binlog 的速度要慢

## 主备延迟的来源

- 有些部署条件下,备库所在机器的性能要比主库所在的机器性能差(这种部署现在比较少了)

现在比较常见的情况是:因为主备可能发生切换,备库随时可能变成主库,所以主备库选用相同规格的机器,并且做对称部署

- 备库的压力大:备库上的查询耗费了大量的 CPU 资源,影响了同步速度,造成主备延迟

解决:一主多从; 除了备库外,可以多接几个从库,让这些从库来分担读的压力;或者通过 binlog 输出到外部系统,比如 Hadoop 这类系统,让外部系统提供统计类查询的能力

- 大事务:主库上必须等事务执行完成才会写入 binlog,再传给备库
- 备库的并行复制能力

说下一些大事务的场景:一次性地用 delete 语句删除太多数据以及大表 DDL 都是典型的大事务场景

由于主备延迟的存在,所以在主备切换的时候,就相应的有不同的策略

## 可靠性优先策略

双 M 结构下

- 判断备库 B 现在的 seconds_behind_master,如果小于某个值(比如 5 秒)继续下一步,否则持续重试这一步
- 把主库 A 改成只读状态,即把 readonly 设置为 true
- 判断备库 B 的 seconds_behind_master 的值,直到这个值变成 0 为止
- 把备库 B 改成可读写状态,也就是把 readonly 设置为 false
- 把业务请求切到备库 B

总结就是:当主备延迟比较小时就把主库设置为只读,到主备延迟为0时进行切换

这个切换流程中是有不可用时间的,在主库A修改为只读状态时,主库 A 和备库 B 都处于 readonly 状态(这部分时间就取决于备库 B 的 seconds_behind_master 变为0的时间)

## 可用性优先策略

将上面流程中,步骤4和5调整到最开始执行,这样系统几乎就没有不可用时间了,但是会出现数据不一致的情况(binlog_format=mixed、自增主键 id 发生主备可用性优先策略切换时,数据会出现不一致)

当binlog_format=row时,由于会记录新插入的行的所有字段值,会由于主键冲突报错而停止,这样数据不一致的问题更容易被发现

结论:大多数情况下,建议使用可靠性优先策略; 毕竟对数据服务来说的话,数据的可靠性一般还是要优于可用性的(也并不是绝对的,当业务逻辑依赖库中的数据时,当使用可靠性优先策略时,并不是系统出现只读、不可写的问题,而是系统处于完全不可用的状态)

所以,在满足数据可靠性的前提下,MySQL 高可用系统的可用性,是依赖于主备延迟的; 延迟的时间越小,在主库故障的时候,服务恢复需要的时间就越短,可用性就越高

## 小结

在实际的应用中,更建议使用可靠性优先的策略; 毕竟保证数据准确,应该是数据库服务的底线; 在这个基础上,通过减少主备延迟,提升系统的可用性