[TOC]

## 内存临时表

```mysql
select word from words order by rand() limit 3;
```

对于临时内存表的排序,对于 InnoDB 表来说,执行全字段排序会减少磁盘访问,因此会被优先选择,但是对于内存(Memory)表,回表过程只是简单地根据数据行的位置,直接访问内存得到数据,根本不会导致多访问磁盘,优化器没有了这一层顾虑,那么它会优先考虑的,就是用于排序的行越小越好了,所以,MySQL 这时就会选择 rowid 排序

上面语句执行的大致流程

- 创建临时表(没有索引),使用的是 Memory 引擎,且该表有两个字段,一个用来存没有索引的内存临时表上,一个用来存单词
- 从 words 表中,按主键顺序取出所有的 word 值; 对于每一个 word 值,调用 rand() 函数生成一个大于 0 小于 1 的随机小数,并分别存入字段中,此时扫描的行数是 全表行数
- 在没有索引的内存临时表上,按照存储随机数的字段排序
- 初始化 sort_buffer,从临时表全表扫描到 sort_buffer 中
- 从排好序的sort_buffer中取出前三个的结果,到临时表中找对应的 word(通过位置信息寻找临时表中的word,而位置信息也存储到sort_buffer中,一般是主键信息,或者是rowid),然后返回结果集

总结

order by rand() 使用了内存临时表,内存临时表排序的时候使用了 rowid 排序方法

### 慢查询日志(slow log)

```mysql
SHOW VARIABLES LIKE '%slow_query%';
SHOW VARIABLES LIKE '%internal_tmp_disk_storage_engine%';
SHOW VARIABLES LIKE '%log_output%';
```

## 磁盘临时表

tmp_table_size 这个配置限制了内存临时表的大小,默认值是 16M; 如果临时表大小超过了 tmp_table_size,那么内存临时表就会转成磁盘临时表

MySQL 8.0+中磁盘临时表强制使用 `InnoDB` 引擎

使用临时表

```mysql
-- 设置内存临时表的大小
set tmp_table_size=1024;
-- 设置sort_buffer的大小
set sort_buffer_size=32768;
-- 决定使用全字段排序还是rowid 排序
set max_length_for_sort_data=16;
/* 打开 optimizer_trace,只对本线程有效 */
SET optimizer_trace='enabled=on'; 

/* 执行语句 */
select word from words order by rand() limit 3;

/* 查看 OPTIMIZER_TRACE 输出 */
SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G
```

排序模式判断逻辑

- 如果查询中所有需要返回的字段(即 `SELECT` 后的字段,或 `ORDER BY` 后涉及的字段)的预估总长度 <= `max_length_for_sort_data`,则优先使用全字段排序;否则,退而使用 rowid 排序

上面的语句中参与排序的行数占用总大小在数据上超过了sort_buffer_size大小,但是上面的语句没有使用临时文件的算法,也就是归并排序算法,而是采用了优先队列排序算法(MySQL 5.6 版本引入的一个新的排序算法,堆排序)